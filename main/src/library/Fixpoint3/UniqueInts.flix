/*
 * Copyright 2025 Casper Dalgaard Nielsen
 *                Adam Yasser Tallouzi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///
/// The purpuse of `UniqueInts` is to assign unique numbers/identifiers to elements.
///
/// A map from the assigned identifiers to the original values is also provided.
///

mod Fixpoint3 {
    @Internal
    pub enum UniqueInts[k: Type, r: Region] {
        case UniqueInts(MutMap[k, Int32, r], Counter[r])
    }

    @Internal
    pub enum ReverseUniqueInts[k: Type] {
        case ReverseUniqueInts(Map[Int32, k])
    }

    mod UniqueInts {
        use Fixpoint3.Counter
        use Fixpoint3.ReverseUniqueInts
        use Fixpoint3.ReverseUniqueInts.ReverseUniqueInts
        use Fixpoint3.UniqueInts

        ///
        /// Returns an empty mapping from `k` to identifiers.
        ///
        @Internal
        pub def empty(rc: Region[r]): UniqueInts[k, r] \ r = UniqueInts(MutMap.empty(rc), Counter.fresh(rc))

        ///
        /// Returns the index of `val` generated by `state`.
        ///
        @Internal
        pub def getIndex(val: k, state: UniqueInts[k, r]): Int32 \ r with Order[k] =
            let UniqueInts(map, counter) = state;
            match MutMap.get(val, map) {
                case None =>
                    let id = Counter.getAndIncrement(counter);
                    MutMap.put(val, id, map);
                    id
                case Some(v) => v
            }

        ///
        /// Returns the current mapping of `state` as a map.
        ///
        @Internal
        pub def toMap(state: UniqueInts[k, r]): Map[k, Int32] \ r = {
            let UniqueInts(internalMap, _) = state;
            internalMap |> MutMap.toMap
        }

        ///
        /// Returns the maximal assigned identifier of `state`.
        ///
        @Internal
        pub def get(state: UniqueInts[k, r]): Int32 \ r = {
            let UniqueInts(_, counter) = state;
            Counter.get(counter)
        }

        ///
        /// Returns an `ReverseUniqueInts` of `state` allowing mapping identifiers
        /// back to the values they represent.
        ///
        @Internal
        pub def reverse(state: UniqueInts[k, r]): ReverseUniqueInts[k] \ r with Order[k] =
            let UniqueInts(map, _) = (state);
            ReverseUniqueInts(MutMap.foldLeftWithKey(acc -> key -> val -> Map.insert(val, key, acc), Map#{}, map))
    }

    mod ReverseUniqueInts {
        use Fixpoint3.ReverseUniqueInts
        use Fixpoint3.Helpers.unwrapOrCrash

        ///
        /// Returns an `ReverseUniqueInts` the value was assigned
        /// the identifier `val`
        ///
        pub def fromIndex(val: Int32, reverseState: ReverseUniqueInts[k]): k =
            let ReverseUniqueInts(r) = reverseState;
            unwrapOrCrash(Map.get(val, r))
    }

}
