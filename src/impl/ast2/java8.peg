//===========================================================================
//
//  Parsing Expression Grammar of Java 1.8 for Mouse 1.6.
//  Based on Java Language Specification, Java SE8 Edition, dated 2014-03-03,
//  obtained from http://docs.oracle.com/javase/specs/jls/se8/jls8-diffs.pdf
//  and parser code from openjdk.8b132.2014.03.03.
//
//---------------------------------------------------------------------------
//
//  Copyright (C) 2014
//  by Roman R Redziejowski(www.romanredz.se).
//
//  The author gives unlimited permission to copy and distribute
//  this file, with or without modifications, as long as this notice
//  is preserved, and any changes are properly documented.
//
//  This file is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
//---------------------------------------------------------------------------
//
//  Latest update 2014-11-01
//
//---------------------------------------------------------------------------
//  Change log
//---------------------------------------------------------------------------
//
//    2014-10-27 Posted on Internet.
//    2014-11-01 Corrected NormalInterfaceDeclaration.
//
//===========================================================================

//=========================================================================
//  Compilation
//=========================================================================

Compilation
    = Spacing CompilationUnit SUB? EOT;


//=========================================================================
//  JLS 3  Lexical Structure
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 3.1-3  Unicode
//-------------------------------------------------------------------------
//  The Unicode escapes in Java source are converted
//  to Java characters by a preprocessor prior to parsing.
//  This is not emulated here; the Unicode escapes are only allowed
//  in string and character literals. They are treated as error in other
//  structures (except comments). The warning in JLS 3.10.5 against using
//  Unicode escapes for line terminators and quotes in string and character
//  literals does not apply here.
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//  JLS 3.5  Input Elements and Tokens
//-------------------------------------------------------------------------

SUB = "\u001a" ;
EOT = !_ ;

//-------------------------------------------------------------------------
//  JLS 3.6-7  Spacing
//-------------------------------------------------------------------------

Spacing
    = ( [ \t\r\n\u000C]+  // WhiteSpace
      / "/*" _*+ "*/"     // TraditionalComment
      / "//" _*+ [\r\n]   // EndOfLineComment
      )* ;

//-------------------------------------------------------------------------
//  JLS 3.8  Identifiers
//-------------------------------------------------------------------------

Identifier  = !Keyword Letter LetterOrDigit* Spacing ;

Letter = [a-z] / [A-Z] / [_$] ;

LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] ;

// These are traditional definitions of letters and digits.
// JLS defines letters and digits as Unicode characters recognized
// as such by special Java procedures, which is difficult
// to express in terms of Parsing Expressions.

//-------------------------------------------------------------------------
//  JLS 3.9  Keywords
//  More precisely: reserved words. According to JLS, "true", "false",
//  and "null" are technically not keywords - but still must not appear
//  as identifiers. Keywords "const" and "goto" are not used; JLS explains
//  the reason.
//-------------------------------------------------------------------------

Keyword
    = ( "abstract"
      / "assert"
      / "boolean"
      / "break"
      / "byte"
      / "case"
      / "catch"
      / "char"
      / "class"
      / "const"
      / "continue"
      / "default"
      / "double"
      / "do"
      / "else"
      / "enum"
      / "extends"
      / "false"
      / "finally"
      / "final"
      / "float"
      / "for"
      / "goto"
      / "if"
      / "implements"
      / "import"
      / "interface"
      / "int"
      / "instanceof"
      / "long"
      / "native"
      / "new"
      / "null"
      / "package"
      / "private"
      / "protected"
      / "public"
      / "return"
      / "short"
      / "static"
      / "strictfp"
      / "super"
      / "switch"
      / "synchronized"
      / "this"
      / "throws"
      / "throw"
      / "transient"
      / "true"
      / "try"
      / "void"
      / "volatile"
      / "while"
      ) !LetterOrDigit
    ;

ABSTRACT     = "abstract"     !LetterOrDigit Spacing ;
ASSERT       = "assert"       !LetterOrDigit Spacing ;
BOOLEAN      = "boolean"      !LetterOrDigit Spacing ;
BREAK        = "break"        !LetterOrDigit Spacing ;
BYTE         = "byte"         !LetterOrDigit Spacing ;
CASE         = "case"         !LetterOrDigit Spacing ;
CATCH        = "catch"        !LetterOrDigit Spacing ;
CHAR         = "char"         !LetterOrDigit Spacing ;
CLASS        = "class"        !LetterOrDigit Spacing ;
CONTINUE     = "continue"     !LetterOrDigit Spacing ;
DEFAULT      = "default"      !LetterOrDigit Spacing ;
DOUBLE       = "double"       !LetterOrDigit Spacing ;
DO           = "do"           !LetterOrDigit Spacing ;
ELSE         = "else"         !LetterOrDigit Spacing ;
ENUM         = "enum"         !LetterOrDigit Spacing ;
EXTENDS      = "extends"      !LetterOrDigit Spacing ;
FALSE        = "false"        !LetterOrDigit Spacing ;
FINALLY      = "finally"      !LetterOrDigit Spacing ;
FINAL        = "final"        !LetterOrDigit Spacing ;
FLOAT        = "float"        !LetterOrDigit Spacing ;
FOR          = "for"          !LetterOrDigit Spacing ;
IF           = "if"           !LetterOrDigit Spacing ;
IMPLEMENTS   = "implements"   !LetterOrDigit Spacing ;
IMPORT       = "import"       !LetterOrDigit Spacing ;
INTERFACE    = "interface"    !LetterOrDigit Spacing ;
INT          = "int"          !LetterOrDigit Spacing ;
INSTANCEOF   = "instanceof"   !LetterOrDigit Spacing ;
LONG         = "long"         !LetterOrDigit Spacing ;
NATIVE       = "native"       !LetterOrDigit Spacing ;
NEW          = "new"          !LetterOrDigit Spacing ;
NULL         = "null"         !LetterOrDigit Spacing ;
PACKAGE      = "package"      !LetterOrDigit Spacing ;
PRIVATE      = "private"      !LetterOrDigit Spacing ;
PROTECTED    = "protected"    !LetterOrDigit Spacing ;
PUBLIC       = "public"       !LetterOrDigit Spacing ;
RETURN       = "return"       !LetterOrDigit Spacing ;
SHORT        = "short"        !LetterOrDigit Spacing ;
STATIC       = "static"       !LetterOrDigit Spacing ;
STRICTFP     = "strictfp"     !LetterOrDigit Spacing ;
SUPER        = "super"        !LetterOrDigit Spacing ;
SWITCH       = "switch"       !LetterOrDigit Spacing ;
SYNCHRONIZED = "synchronized" !LetterOrDigit Spacing ;
THIS         = "this"         !LetterOrDigit Spacing ;
THROWS       = "throws"       !LetterOrDigit Spacing ;
THROW        = "throw"        !LetterOrDigit Spacing ;
TRANSIENT    = "transient"    !LetterOrDigit Spacing ;
TRUE         = "true"         !LetterOrDigit Spacing ;
TRY          = "try"          !LetterOrDigit Spacing ;
VOID         = "void"         !LetterOrDigit Spacing ;
VOLATILE     = "volatile"     !LetterOrDigit Spacing ;
WHILE        = "while"        !LetterOrDigit Spacing ;

//-------------------------------------------------------------------------
//  JLS 3.10  Literals
//-------------------------------------------------------------------------

Literal
    = FloatLiteral
    / IntegerLiteral          // May be a prefix of FloatLiteral
    / BooleanLiteral
    / CharLiteral
    / StringLiteral
    / NullLiteral
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.1  Floating-point Literals
//-------------------------------------------------------------------------

IntegerLiteral
    = ( HexNumeral
      / BinaryNumeral
      / OctalNumeral            // May be a prefix of HexNumeral or BinaryNumeral
      / DecimalNumeral          // May be a prefix of OctalNumeral
      ) [lL]? Spacing
    ;

DecimalNumeral
    = "0"
    / [1-9]([_]*[0-9])*
    ;

HexNumeral
    = ("0x" / "0X") HexDigits ;

OctalNumeral
    = "0" ([_]*[0-7])+ ;

BinaryNumeral
    = ("0b" / "0B") [01]([_]*[01])* ;

//-------------------------------------------------------------------------
//  JLS 3.10.2  Integer Literals
//-------------------------------------------------------------------------

FloatLiteral
    = ( HexadecimalFloatingPointLiteral
      / DecimalFloatingPointLiteral   // May be a prefix of above
      ) Spacing
    ;

DecimalFloatingPointLiteral
    = Digits "." Digits?  Exponent? [fFdD]?
    / "." Digits Exponent? [fFdD]?
    / Digits Exponent [fFdD]?
    / Digits Exponent? [fFdD]
    ;

Exponent
    = [eE] [+\-]? Digits ;

HexadecimalFloatingPointLiteral
    = HexSignificand BinaryExponent [fFdD]? ;

HexSignificand
    = ("0x" / "0X") HexDigits? "." HexDigits
    / HexNumeral "."?                           // May be a prefix of above
    ;

HexDigits
    = HexDigit ([_]*HexDigit)* ;

HexDigit
    = [a-f] / [A-F] / [0-9] ;

BinaryExponent
    = [pP] [+\-]? Digits ;

Digits
    = [0-9]([_]*[0-9])* ;

//-------------------------------------------------------------------------
//  JLS 3.10.3  Boolean Literals
//-------------------------------------------------------------------------

BooleanLiteral
    = TRUE
    / FALSE
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.4  Character Literals
//-------------------------------------------------------------------------

CharLiteral
    = "'" (Escape / !['\\\n\r] _) "'" Spacing            // this " keeps the editor happy
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.5 String Literals
//-------------------------------------------------------------------------

StringLiteral
    = "\"" (Escape / !["\\\n\r] _)* "\"" Spacing         // this " keeps the editor happy
    ;

Escape
    = "\\" ([btnfr"'\\] / OctalEscape / UnicodeEscape)   // this " keeps the editor happy
    ;

OctalEscape
    = [0-3][0-7][0-7]
    / [0-7][0-7]
    / [0-7]
    ;

UnicodeEscape
    = "u"+ HexDigit HexDigit HexDigit HexDigit ;

//-------------------------------------------------------------------------
//  JLS 3.10.6 The Null literal
//-------------------------------------------------------------------------

NullLiteral = NULL ;

//-------------------------------------------------------------------------
//  JLS 3.11  Separators
//-------------------------------------------------------------------------

AT              =   "@"       Spacing ;
COLONCOLON      =   "::"      Spacing ;
COMMA           =   ","       Spacing ;
DOT             =   "."       Spacing ;
ELLIPSIS        =   "..."     Spacing ;
LPAR            =   "("       Spacing ;
LBRK            =   "["       Spacing ;
RBRK            =   "]"       Spacing ;
RPAR            =   ")"       Spacing ;
LWING           =   "{"       Spacing ;
RWING           =   "}"       Spacing ;
SEMI            =   ";"       Spacing ;

//-------------------------------------------------------------------------
//  JLS 3.12  Operators
//  The operators < and > is defined uder two names:
//  LT and GT, respectively LPOINT and RPOINT.
//  The last two are used in the type context, to emulate the translation
//  rule given in JLS 3.2.
//-------------------------------------------------------------------------

AND             =   "&"![=&]  Spacing ;
ANDAND          =   "&&"      Spacing ;
ANDEQU          =   "&="      Spacing ;
ARROW           =   "->"      Spacing ;
BANG            =   "!" ![=]  Spacing ;
BSR             =   ">>>"![=] Spacing ;
BSREQU          =   ">>>="    Spacing ;
COLON           =   ":" ![:]  Spacing ;
DEC             =   "--"      Spacing ;
DIV             =   "/" ![=]  Spacing ;
DIVEQU          =   "/="      Spacing ;
EQU             =   "=" ![=]  Spacing ;
EQUAL           =   "=="      Spacing ;
GE              =   ">="      Spacing ;
GT              =   ">"![=>]  Spacing ;
HAT             =   "^"![=]   Spacing ;
HATEQU          =   "^="      Spacing ;
INC             =   "++"      Spacing ;
LE              =   "<="      Spacing ;
LPOINT          =   "<"       Spacing ;
LT              =   "<"![=<]  Spacing ;
MINUS           =   "-"![=\->]Spacing ;
MINUSEQU        =   "-="      Spacing ;
MOD             =   "%"![=]   Spacing ;
MODEQU          =   "%="      Spacing ;
NOTEQUAL        =   "!="      Spacing ;
OR              =   "|"![=|]  Spacing ;
OREQU           =   "|="      Spacing ;
OROR            =   "||"      Spacing ;
PLUS            =   "+"![=+]  Spacing ;
PLUSEQU         =   "+="      Spacing ;
QUERY           =   "?"       Spacing ;
RPOINT          =   ">"       Spacing ;
SL              =   "<<"![=]  Spacing ;
SLEQU           =   "<<="     Spacing ;
SR              =   ">>"![=>] Spacing ;
SREQU           =   ">>="     Spacing ;
STAR            =   "*"![=]   Spacing ;
STAREQU         =   "*="      Spacing ;
TILDE           =   "~"       Spacing ;


//=========================================================================
//  JLS 4  Types, Values and Variables
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 4.2  Primitive Types and Values
//-------------------------------------------------------------------------

BasicType
    = BYTE
    / SHORT
    / INT
    / LONG
    / CHAR
    / FLOAT
    / DOUBLE
    / BOOLEAN
    ;

PrimitiveType
    = Annotation* BasicType ;

//-------------------------------------------------------------------------
//  JLS 4.3  Reference Types and Values
//-------------------------------------------------------------------------

ReferenceType
    = PrimitiveType Dim+
    / ClassType Dim*
    ;

ClassType
    = Annotation* Identifier TypeArguments?
          (DOT Annotation* Identifier TypeArguments?)* ;

Type
    = PrimitiveType
    / ClassType
    ;

ArrayType
    = PrimitiveType Dim+
    / ClassType Dim+
    ;

TypeVariable
    = Annotation* Identifier ;

Dim
    = Annotation* LBRK RBRK ;

//-------------------------------------------------------------------------
//  JLS 4.4  Type Variables
//-------------------------------------------------------------------------

TypeParameter
    = TypeParameterModifier* Identifier TypeBound? ;

TypeParameterModifier
    = Annotation ;

TypeBound
    = EXTENDS (ClassType AdditionalBound* / TypeVariable) ;

AdditionalBound
    = AND ClassType ;

//-------------------------------------------------------------------------
//  JLS 4.5  Parametrized Types
//-------------------------------------------------------------------------

TypeArguments
    = LPOINT TypeArgumentList RPOINT ;

TypeArgumentList
    = TypeArgument (COMMA TypeArgument)* ;

TypeArgument
    = ReferenceType
    / Wildcard
    ;

Wildcard
    = Annotation* QUERY WildcardBounds? ;

WildcardBounds
    = EXTENDS ReferenceType
    / SUPER ReferenceType
    ;


//=========================================================================
//  JLS 6  Names
//=========================================================================

QualIdent
    = Identifier (DOT Identifier)* ;


//=========================================================================
//  JLS 7  Packages
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 7.3  Compilation Units
//-------------------------------------------------------------------------

CompilationUnit
    = PackageDeclaration? ImportDeclaration* TypeDeclaration* ;

//-------------------------------------------------------------------------
//  JLS 7.4  Package Declarations
//-------------------------------------------------------------------------

PackageDeclaration
    = PackageModifier* PACKAGE Identifier (DOT Identifier)* SEMI ;

PackageModifier
    = Annotation ;

//-------------------------------------------------------------------------
//  JLS 7.5  Import Declarations
//-------------------------------------------------------------------------

ImportDeclaration
    = IMPORT STATIC? QualIdent (DOT STAR)? SEMI
    / SEMI
    ;

//-------------------------------------------------------------------------
//  JLS 7.6  Top Level Type Declarations
//-------------------------------------------------------------------------

TypeDeclaration
    = ClassDeclaration
    / InterfaceDeclaration
    / SEMI
    ;


//=========================================================================
//  JLS 8  Classes
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 8.1  Class Declarations
//-------------------------------------------------------------------------

ClassDeclaration
    = NormalClassDeclaration
    / EnumDeclaration
    ;

NormalClassDeclaration
    = ClassModifier* CLASS Identifier TypeParameters?
          Superclass? Superinterfaces? ClassBody
    ;

ClassModifier
    = Annotation
    / PUBLIC
    / PROTECTED
    / PRIVATE
    / ABSTRACT
    / STATIC
    / FINAL
    / STRICTFP
    ;

TypeParameters
    = LPOINT TypeParameterList RPOINT ;

TypeParameterList
    = TypeParameter (COMMA TypeParameter)* ;

Superclass
    = EXTENDS ClassType ;

Superinterfaces
    = IMPLEMENTS InterfaceTypeList ;

InterfaceTypeList
    = ClassType (COMMA ClassType)* ;

ClassBody
    = LWING ClassBodyDeclaration* RWING ;

ClassBodyDeclaration
    = ClassMemberDeclaration
    / InstanceInitializer
    / StaticInitializer
    / ConstructorDeclaration
    ;

ClassMemberDeclaration
    = FieldDeclaration
    / MethodDeclaration
    / ClassDeclaration
    / InterfaceDeclaration
    / SEMI
    ;

//-------------------------------------------------------------------------
//  JLS 8.3  Field Declarations
//-------------------------------------------------------------------------

FieldDeclaration
    = FieldModifier* UnannType VariableDeclaratorList SEMI ;

VariableDeclaratorList
    = VariableDeclarator (COMMA VariableDeclarator)* ;

VariableDeclarator
    = VariableDeclaratorId (EQU VariableInitializer)? ;

VariableDeclaratorId
    = Identifier Dim* ;

VariableInitializer
    = Expression
    / ArrayInitializer
    ;

UnannClassType
    = Identifier TypeArguments?
          (DOT Annotation* Identifier TypeArguments?)*  ;

UnannType
    = BasicType Dim*
    / UnannClassType Dim*
    ;

FieldModifier
    = Annotation
    / PUBLIC
    / PROTECTED
    / PRIVATE
    / STATIC
    / FINAL
    / TRANSIENT
    / VOLATILE
    ;

//-------------------------------------------------------------------------
//  JLS 8.4  Method Declarations
//-------------------------------------------------------------------------

MethodDeclaration
    = MethodModifier* MethodHeader MethodBody ;

MethodHeader
    = Result MethodDeclarator Throws?
    / TypeParameters Annotation* Result MethodDeclarator Throws?
    ;

MethodDeclarator
    = Identifier LPAR FormalParameterList? RPAR Dim* ;

FormalParameterList
    = (ReceiverParameter / FormalParameter)(COMMA FormalParameter)* ;

FormalParameter
    = VariableModifier* UnannType VariableDeclaratorId
    / VariableModifier* UnannType Annotation* ELLIPSIS VariableDeclaratorId !COMMA
    ;

VariableModifier
    = Annotation
    / FINAL
    ;

ReceiverParameter
    = VariableModifier* UnannType (Identifier DOT)? THIS ;

Result
    = UnannType
    / VOID
    ;

MethodModifier
    = Annotation
    / PUBLIC
    / PROTECTED
    / PRIVATE
    / ABSTRACT
    / STATIC
    / FINAL
    / SYNCHRONIZED
    / NATIVE
    / STRICTFP
    ;

Throws
    = THROWS ExceptionTypeList ;

ExceptionTypeList
    = ExceptionType (COMMA ExceptionType)* ;

ExceptionType
    = ClassType
    / TypeVariable
    ;

MethodBody
    = Block
    / SEMI
    ;

//-------------------------------------------------------------------------
//  JLS 8.6  Instance Initializers
//-------------------------------------------------------------------------

InstanceInitializer
    = Block ;

//-------------------------------------------------------------------------
//  JLS 8.7  Static Initializers
//-------------------------------------------------------------------------

StaticInitializer
    = STATIC Block ;

//-------------------------------------------------------------------------
//  JLS 8.8  Constructor Declarations
//-------------------------------------------------------------------------

ConstructorDeclaration
    = ConstructorModifier* ConstructorDeclarator Throws? ConstructorBody ;

ConstructorDeclarator
    = TypeParameters? SimpleQualIdent LPAR FormalParameterList? RPAR ;

SimpleQualIdent
    = Identifier ;

ConstructorModifier
    = Annotation
    / PUBLIC
    / PROTECTED
    / PRIVATE
    ;

ConstructorBody
    = LWING ExplicitConstructorInvocation? BlockStatements? RWING ;

ExplicitConstructorInvocation
    = TypeArguments? THIS Arguments SEMI
    / TypeArguments? SUPER Arguments SEMI
    / Primary DOT TypeArguments? SUPER Arguments SEMI
    / QualIdent DOT TypeArguments? SUPER Arguments SEMI
    ;

//-------------------------------------------------------------------------
//  JLS 8.9  Enum Types
//-------------------------------------------------------------------------

EnumDeclaration
    = ClassModifier* ENUM Identifier Superinterfaces? EnumBody ;

EnumBody
    = LWING EnumConstantList? COMMA? EnumBodyDeclarations? RWING ;

EnumConstantList
    = EnumConstant (COMMA EnumConstant)* ;

EnumConstant
    = EnumConstantModifier* Identifier Arguments? ClassBody? ;

EnumConstantModifier
    = Annotation ;

EnumBodyDeclarations
    = SEMI ClassBodyDeclaration* ;


//=========================================================================
//  JLS 9  Interfaces
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 9.1  Interface Declarations
//-------------------------------------------------------------------------

InterfaceDeclaration
    = NormalInterfaceDeclaration
    / AnnotationTypeDeclaration
    ;

NormalInterfaceDeclaration
    = InterfaceModifier* INTERFACE Identifier TypeParameters?
          ExtendsInterfaces? InterfaceBody ;

InterfaceModifier
    = Annotation
    / PUBLIC
    / PROTECTED
    / PRIVATE
    / ABSTRACT
    / STATIC
    / STRICTFP
    ;

ExtendsInterfaces
    = EXTENDS InterfaceTypeList ;

InterfaceBody
    = LWING InterfaceMemberDeclaration* RWING ;

InterfaceMemberDeclaration
    = ConstantDeclaration
    / InterfaceMethodDeclaration
    / ClassDeclaration
    / InterfaceDeclaration
    / SEMI
    ;

//-------------------------------------------------------------------------
//  JLS 9.3  Field (Constant) Declarations
//-------------------------------------------------------------------------

ConstantDeclaration
    = ConstantModifier* UnannType VariableDeclaratorList SEMI ;

ConstantModifier
    = Annotation
    / PUBLIC
    / STATIC
    / FINAL
    ;

//-------------------------------------------------------------------------
//  JLS 9.4  Method Declarations
//-------------------------------------------------------------------------

InterfaceMethodDeclaration
    = InterfaceMethodModifier* MethodHeader MethodBody ;

InterfaceMethodModifier
    = Annotation
    / PUBLIC
    / ABSTRACT
    / DEFAULT
    / STATIC
    / STRICTFP
    ;

//-------------------------------------------------------------------------
//  JLS 9.6  Annotation types
//-------------------------------------------------------------------------

AnnotationTypeDeclaration
    = InterfaceModifier* AT INTERFACE Identifier AnnotationTypeBody ;

AnnotationTypeBody
    = LWING AnnotationTypeMemberDeclaration* RWING ;

AnnotationTypeMemberDeclaration
    = AnnotationTypeElementDeclaration
    / ConstantDeclaration
    / ClassDeclaration
    / InterfaceDeclaration
    / SEMI
    ;

AnnotationTypeElementDeclaration
    = AnnotationTypeElementModifier* UnannType Identifier LPAR RPAR Dim*
         DefaultValue? SEMI ;

AnnotationTypeElementModifier
    = Annotation
    / PUBLIC
    / ABSTRACT
    ;

DefaultValue
    = DEFAULT ElementValue ;

//-------------------------------------------------------------------------
//  JLS 9.7  Annotations
//-------------------------------------------------------------------------

Annotation
    = AT
      ( NormalAnnotation
      / SingleElementAnnotation
      / MarkerAnnotation
      )
    ;

NormalAnnotation
    = QualIdent LPAR ElementValuePairList* RPAR ;

ElementValuePairList
    = ElementValuePair (COMMA ElementValuePair)* ;

ElementValuePair
    = Identifier EQU ElementValue ;

ElementValue
    = ConditionalExpression
    / ElementValueArrayInitializer
    / Annotation
    ;

ElementValueArrayInitializer
    = LWING ElementValueList? COMMA? RWING ;

ElementValueList
    = ElementValue (COMMA ElementValue)* ;

MarkerAnnotation
    = QualIdent ;

SingleElementAnnotation
    = QualIdent LPAR ElementValue RPAR ;


//=========================================================================
//  JLS 10  Arrays
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 10.6  Array Initializers
//-------------------------------------------------------------------------

ArrayInitializer
    = LWING VariableInitializerList? COMMA? RWING ;

VariableInitializerList
    = VariableInitializer (COMMA VariableInitializer)* ;

//=========================================================================
//  JLS 14  Blocks and Statements
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 14.2 Blocks
//-------------------------------------------------------------------------

Block
    = LWING BlockStatements? RWING ;

BlockStatements
    = BlockStatement BlockStatement* ;

BlockStatement
    = LocalVariableDeclarationStatement
    / ClassDeclaration
    / Statement
    ;

//-------------------------------------------------------------------------
//  JLS 14.4  Local Variable Declaration Statements
//-------------------------------------------------------------------------

LocalVariableDeclarationStatement
    = LocalVariableDeclaration SEMI ;

LocalVariableDeclaration
    = VariableModifier* UnannType VariableDeclaratorList ;

//-------------------------------------------------------------------------
//  JLS 14.5  Statements
//-------------------------------------------------------------------------

Statement
    = Block
    / IF ParExpression Statement (ELSE Statement)?
    / BasicForStatement
    / EnhancedForStatement
    / WHILE ParExpression Statement
    / DO Statement WHILE ParExpression SEMI
    / TryStatement
    / SWITCH ParExpression SwitchBlock
    / SYNCHRONIZED ParExpression Block
    / RETURN Expression? SEMI
    / THROW Expression SEMI
    / BREAK Identifier? SEMI
    / CONTINUE Identifier? SEMI
    / ASSERT Expression (COLON Expression)? SEMI
    / SEMI
    / StatementExpression SEMI
    / Identifier COLON Statement
    ;

//-------------------------------------------------------------------------
//  JLS 14.8  Expression Statements
//
//  Each of MethodInvocation and ClassInstanceCreationExpression
//  can be a prefix of the other one. Until a solution is found,
//  they are replaced by Primary.
//-------------------------------------------------------------------------

StatementExpression
    = Assignment
    / (INC / DEC)(Primary / QualIdent)
    / (Primary / QualIdent)(INC / DEC)
    / Primary
//    / MethodInvocation
//    / ClassInstanceCreationExpression
    ;

//-------------------------------------------------------------------------
//  JLS 14.11  The SWITCH Statement
//-------------------------------------------------------------------------

SwitchBlock
    = LWING SwitchBlockStatementGroup* SwitchLabel* RWING ;

SwitchBlockStatementGroup
    = SwitchLabels BlockStatements ;

SwitchLabels
    = SwitchLabel SwitchLabel* ;

SwitchLabel
    = CASE (ConstantExpression / EnumConstantName) COLON
    / DEFAULT COLON
    ;

EnumConstantName
    = Identifier ;

//-------------------------------------------------------------------------
//  JLS 14.14  The FOR Statement
//-------------------------------------------------------------------------

BasicForStatement
    = FOR LPAR ForInit? SEMI Expression? SEMI ForUpdate? RPAR Statement ;

ForInit
    = LocalVariableDeclaration
    / StatementExpressionList
    ;

ForUpdate
    = StatementExpressionList ;

StatementExpressionList
    = StatementExpression (COMMA  StatementExpression)* ;

EnhancedForStatement
    = FOR LPAR VariableModifier* UnannType VariableDeclaratorId COLON
          Expression RPAR Statement ;

//-------------------------------------------------------------------------
//  JLS 14.20  The TRY Statement
//-------------------------------------------------------------------------

TryStatement
    = TRY
      ( Block (CatchClause* Finally / CatchClause+)
      / ResourceSpecification Block CatchClause* Finally?
      )
    ;

CatchClause
    = CATCH LPAR CatchFormalParameter RPAR Block ;

CatchFormalParameter
    = VariableModifier* CatchType VariableDeclaratorId ;

CatchType
    = UnannClassType (OR ClassType)* ;

Finally
    = FINALLY Block ;

ResourceSpecification
    = LPAR ResourceList SEMI? RPAR ;

ResourceList
    = Resource (SEMI Resource)* ;

Resource
    = VariableModifier* UnannType VariableDeclaratorId EQU Expression ;


//=========================================================================
//  JLS 15  Expressions
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 15.2  Forms of Expression
//-------------------------------------------------------------------------

Expression
    = LambdaExpression
    / AssignmentExpression
    ;

//-------------------------------------------------------------------------
//  JLS 15.8  Primary Expression
//-------------------------------------------------------------------------

Primary
    = PrimaryBase PrimaryRest* ;

PrimaryBase
    = THIS
    / Literal
    / ParExpression
    / SUPER
      ( DOT TypeArguments? Identifier Arguments  // MethodInvocation
      / DOT Identifier  // FieldAccess
      / COLONCOLON TypeArguments? Identifier      // MethodReference
      )
    / NEW
      ( ClassCreator  // Class creation
      / ArrayCreator  // Array creation
      )
    / QualIdent
      ( LBRK Expression RBRK // ArrayAccess
      / Arguments  // MethodInvocation
      / DOT
        ( THIS
        / NEW ClassCreator  // Class creation
        / TypeArguments Identifier Arguments  // MethodInvocation
        / SUPER DOT TypeArguments? Identifier Arguments  // MethodInvocation
        / SUPER DOT Identifier // FieldAccess
        / SUPER COLONCOLON TypeArguments? Identifier  // MethodReference
        )
      / (LBRK RBRK)* DOT CLASS
      / COLONCOLON TypeArguments? Identifier  // MethodReference
      )
    / VOID DOT CLASS
    / BasicType (LBRK RBRK)* DOT CLASS
    / ReferenceType COLONCOLON TypeArguments? Identifier  // MethodReference
    / ClassType COLONCOLON TypeArguments? NEW  // MethodReference
    / ArrayType COLONCOLON NEW  // MethodReference
    ;

PrimaryRest
    = DOT
      ( TypeArguments? Identifier Arguments  // MethodInvocation
      / Identifier  // FieldAccess
      / NEW ClassCreator  // Class creation
      )
    / LBRK Expression RBRK  // ArrayAccess
    / COLONCOLON TypeArguments? Identifier  // MethodReference
    ;

ParExpression
    = LPAR Expression RPAR ;

//-------------------------------------------------------------------------
//  JLS 15.9  Class Instance Creation Expressions
//-------------------------------------------------------------------------

ClassInstanceCreationExpression
    = NEW ClassCreator
    / Primary DOT NEW ClassCreator
    / QualIdent DOT NEW ClassCreator
    ;

ClassCreator
    = TypeArguments? Annotation* ClassTypeWithDiamond
          Arguments ClassBody? ;

ClassTypeWithDiamond
    = Annotation* Identifier TypeArgumentsOrDiamond?
          (DOT Annotation* Identifier TypeArgumentsOrDiamond?)* ;

TypeArgumentsOrDiamond
    = TypeArguments
    / LPOINT RPOINT !DOT  // Must be last
    ;

//-------------------------------------------------------------------------
//  JLS 15.10  Array Creation and Access Expressions
//-------------------------------------------------------------------------

ArrayCreator
    = Type DimExpr+ Dim*
    / Type Dim+ ArrayInitializer
    ;

DimExpr
    = Annotation* LBRK Expression RBRK ;

ArrayAccess
    = Primary LBRK Expression RBRK
    / QualIdent LBRK Expression RBRK
    ;

//-------------------------------------------------------------------------
//  JLS 15.11  Field Access Expressions
//-------------------------------------------------------------------------

FieldAccess
    = Primary DOT Identifier
    / SUPER DOT Identifier
    / QualIdent DOT SUPER DOT Identifier
    ;

//-------------------------------------------------------------------------
//  JLS 15.12  Method Invocation Expressions
//-------------------------------------------------------------------------

MethodInvocation
    = QualIdent Arguments
    / Primary DOT TypeArguments? Identifier Arguments
    / QualIdent DOT TypeArguments Identifier Arguments
    / SUPER DOT TypeArguments? Identifier Arguments
    / QualIdent DOT SUPER DOT TypeArguments? Identifier Arguments
    ;

Arguments
    = LPAR ArgumentList? RPAR ;

ArgumentList
    = Expression (COMMA Expression)* ;

//-------------------------------------------------------------------------
//  JLS 15.15  Unary Operators
//-------------------------------------------------------------------------

UnaryExpression
    = (INC / DEC)(Primary / QualIdent)
    / PLUS UnaryExpression
    / MINUS UnaryExpression
    / UnaryExpressionNotPlusMinus
    ;

UnaryExpressionNotPlusMinus
    = TILDE UnaryExpression
    / BANG UnaryExpression
    / CastExpression
    / (Primary / QualIdent) (INC / DEC)?
    ;

//-------------------------------------------------------------------------
//  JLS 15.16  Cast Expressions
//-------------------------------------------------------------------------

CastExpression
    = LPAR PrimitiveType RPAR UnaryExpression
    / LPAR ReferenceType AdditionalBound* RPAR LambdaExpression
    / LPAR ReferenceType AdditionalBound* RPAR UnaryExpressionNotPlusMinus
    ;

//-------------------------------------------------------------------------
//  JLS 15.17-24 Infix Expression
//-------------------------------------------------------------------------

InfixExpression
    = UnaryExpression
          ((InfixOperator UnaryExpression) / (INSTANCEOF ReferenceType))* ;

InfixOperator
    = OROR
    / ANDAND
    / OR
    / HAT
    / AND
    / EQUAL
    / NOTEQUAL
    / LT
    / GT
    / LE
    / GE
    / SL
    / SR
    / BSR
    / PLUS
    / MINUS
    / STAR
    / DIV
    / MOD
    ;

//-------------------------------------------------------------------------
//  JLS 15.25  Conditional Operator ? :
//-------------------------------------------------------------------------

ConditionalExpression
    = InfixExpression (QUERY Expression COLON Expression)* ;

//-------------------------------------------------------------------------
//  JLS 15.26  Assignment Operators
//
//  Each of ArrayAccess and FieldAccess in LeftHandSide
//  can be a prefix of the other one.
//  Until a solution is found, they are replaced by Primary.
//-------------------------------------------------------------------------

AssignmentExpression
    = Assignment
    / ConditionalExpression
    ;

Assignment
    = LeftHandSide AssignmentOperator Expression ;

LeftHandSide
//    = ArrayAccess
//    / FieldAccess
    = Primary
    / QualIdent
    ;

AssignmentOperator
    = EQU
    / STAREQU
    / DIVEQU
    / MODEQU
    / PLUSEQU
    / MINUSEQU
    / SLEQU
    / SREQU
    / BSREQU
    / ANDEQU
    / HATEQU
    / OREQU
    ;

//-------------------------------------------------------------------------
//  JLS 15.27  Lambda Expressions
//-------------------------------------------------------------------------

LambdaExpression
    = LambdaParameters ARROW LambdaBody ;

LambdaParameters
    = Identifier
    / LPAR FormalParameterList? RPAR
    / LPAR InferredFormalParameterList RPAR
    ;

InferredFormalParameterList
    = Identifier (COMMA Identifier)* ;

LambdaBody
    = Expression
    / Block
    ;

//-------------------------------------------------------------------------
//  JLS 15.28  Constant Expressions
//-------------------------------------------------------------------------

ConstantExpression
    = Expression ;