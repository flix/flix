/*
 * Copyright 2026 Alexander Sommer, Samuel Skovbakke
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ca.uwaterloo.flix.language.phase.typer

import ca.uwaterloo.flix.language.ast.shared.{Scope, VarText}
import ca.uwaterloo.flix.language.errors.TypeError
import ca.uwaterloo.flix.language.ast.{Kind, Rigidity, RigidityEnv, SourceLocation, Symbol, Type, TypeConstructor}
import ca.uwaterloo.flix.language.phase.typer.EffectProvenance.Vertex.{CstVertex, IOVertex, PureExplicitVertex, PureImplicitVertex, RigidVarVertex, SignatureVertex, VarVertex, sameType}
import ca.uwaterloo.flix.language.phase.typer.EffectProvenance.NodeType.{IntermediateNode, SinkNode, SourceNode}
import ca.uwaterloo.flix.language.phase.typer.TypeConstraint.EffConflicted

import scala.annotation.tailrec
import scala.collection.mutable

/**
  * Analyzes constraints generated by ConstraintSolver in order to provide code actions,
  * inlay hints and better error messages.
  *
  * This module constructs a directed graph representing effect flow from type constraints
  * and performs breadth-first search to identify specific paths from effect to another effect.
  * This helps generate specific errors that help with diagnosing effect related errors.
  * It generates lists of all paths from some effect flowing into another (conflicting) effect.
  */
object EffectProvenance {

  /**
    * Represents a directed edge in the effect constraint graph.
    */
  private case class Edge(v1: Vertex, v2: Vertex, loc: SourceLocation)

  /**
    * Represents a directed graph of effect flow.
    */
  private case class Graph(vertices: List[Vertex], edges: List[Edge])

  /**
    * Represents the lattice used for analysis of effects
    *
    * State = Vertex -> P(Vertex)
    */
  private type MapLattice = Map[Vertex, Set[Vertex]]

  /**
    * Represents a vertex in the effect constraint graph.
    *
    * A Vertex represents one of:
    *   - Explicitly Pure function
    *   - Implicitly Pure function
    *   - The IO effect
    *   - Effect constants, i.e. user-defined effects
    *   - Effect variables
    */
  sealed trait Vertex

  object Vertex {
    /**
      * Explicitly Pure function (has a real source location).
      *
      * Example: def foo(): Unit \ {} = ()
      *
      * @param loc the source location of {}
      */
    case class PureExplicitVertex(loc: SourceLocation) extends Vertex

    /**
      * Implicitly Pure function.
      *
      * Example: def foo(): Unit = ()
      *
      * @param loc the synthetic location, which is the position immediately to the right of the return type.
      */
    case class PureImplicitVertex(loc: SourceLocation) extends Vertex

    /**
      * User-defined effect.
      *
      * @param sym the effect symbol
      * @param loc the source location where the effect is called
      */
    case class CstVertex(sym: Symbol.EffSym, loc: SourceLocation) extends Vertex

    /**
      * The IO effect.
      *
      * @param loc the source location where IO is called
      */
    case class IOVertex(loc: SourceLocation) extends Vertex

    /**
      * A rigid effect variable
      *
      * @param sym the effect variable symbol
      * @param loc the location of the rigid effect variable
      */
    case class RigidVarVertex(sym: Symbol.KindedTypeVarSym, loc: SourceLocation) extends Vertex

    /**
      * Represents the effects in the signature of a function
      */
    case class SignatureVertex(effs: List[Vertex], loc: SourceLocation) extends  Vertex {
      def symbols(): List[Symbol.EffSym] = {
        effs.flatMap {
          case IOVertex(_) => Some(Symbol.IO)
          case CstVertex(sym, _) => Some(sym)
          case RigidVarVertex(sym, _) => sym.text match {
            case VarText.Absent => None
            case VarText.SourceText(s) => Some(Symbol.mkEffSym(s))
          }
          case _ => None
        }
      }
    }

    /**
      * Effect variable.
      *
      * @param sym the effect variable symbol
      */
    case class VarVertex(sym: Symbol.KindedTypeVarSym) extends Vertex

    /**
      * Determines if two vertices are of the same type
      *
      * e.g. IO(1:1) = IO(2:2) indeterminate of location
      */
    def sameType(v1: Vertex, v2: Vertex): Boolean = (v1, v2) match {
      case (IOVertex(_), IOVertex(_)) => true
      case (PureExplicitVertex(_), PureImplicitVertex(_)) => true
      case (PureExplicitVertex(_), PureExplicitVertex(_)) => true
      case (PureImplicitVertex(_), PureImplicitVertex(_)) => true
      case (PureImplicitVertex(_), PureExplicitVertex(_)) => true
      case (CstVertex(sym1, _), CstVertex(sym2, _)) => sym1 == sym2
      case (RigidVarVertex(sym1, _), RigidVarVertex(sym2, _)) => sym1 == sym2
      case _ => false
    }
  }

  /**
    * Represents the type of node constructed in the effect provenance graph
    *
    * This trait allows to differentiate between two Vertices of the same type, differently, determined by the NodeType
    *
    * For example an IO Vertex in a signature, e.g. f(): Unit \ IO
    * is constructed differently than one that appears in a source node. e.g. println("42")
    *
    * This trait is only used when constructing the graph
    */
  sealed trait NodeType

  object NodeType {
    case object SinkNode extends NodeType

    case object IntermediateNode extends NodeType

    case object SourceNode extends NodeType
  }

  /**
    * Builds an effect conflict graph from given constraints.
    * Then analyzes the effect conflict graph and returns a list of effect conflicts.
    *
    * Returns a list of effect conflicts if any are found, or None if no good effect error could be made.
    * A conflict is: a path from an effect to a differing effect. E.g. IO -> ... -> {}.
    * This is the main entry point for effect provenance analysis.
    *
    * @param constrs0 the list of type constraints to analyze
    * @return a list of conflicts if conflicts could be found, None otherwise
    */
  def getErrors(constrs0: List[TypeConstraint])(implicit scope: Scope, renv: RigidityEnv): Option[List[EffConflicted]] = {
    val graph = buildGraph(constrs0)
    graph.flatMap(analysis)
  }

  private def analysis(graph: Graph): Option[List[EffConflicted]] = {
    def helper(ml: MapLattice): MapLattice = {
      graph.edges.foldLeft(ml) {
        case (acc, Edge(from, to, _)) =>
          val f = acc.get((from))
          val t = acc.get((to))
          f match {
            case None => t match {
              case Some(ys) => acc + (to -> (ys))
              case None => acc + (to -> Set(from))
            }
            case Some(xs) => t match {
              case Some(ys) => acc + (to -> (ys ++ xs))
              case None => acc + (to -> xs)
            }

          }
      }
    }

    var fp = helper(Map.empty: MapLattice)
    while (fp != helper(fp)) {
      fp = helper(fp)
    }
    val res = fp.foldLeft(List.empty[EffConflicted]) {
      case (acc, (v, vs)) =>
        val filtered = vs.filterNot {
          case VarVertex(_) => true
          case _ => false
        }
        if (isConflicting(v, filtered)) mkError(v, filtered) ::: acc else acc
    }
    if (res.isEmpty) None else Some(res)
  }

  /**
    * Constructs an effect provenance graph from type constraints.
    *
    * The graph represents flow of effects through the program. An edge from A to B
    * means that effect A flows to B.
    *
    * @param constraints the type constraints to analyze
    * @return Some(graph) if one or more edges could be created, otherwise None
    */
  private def buildGraph(constraints: List[TypeConstraint])(implicit scope: Scope, renv: RigidityEnv): Option[Graph] = {
    var flow: List[Edge] = List()
    var v: Set[Vertex] = Set.empty
    constraints.foreach {
      case TypeConstraint.Equality(tpe1, tpe2, prov) => {
        val inf = prov match {
          case TypeConstraint.Provenance.ExpectEffect(_, _, _) => Some((SinkNode, IntermediateNode, prov.loc))
          case TypeConstraint.Provenance.Source(_, _, _) => Some((IntermediateNode, SourceNode, prov.loc))
          case TypeConstraint.Provenance.Match(_, _, _) => Some((IntermediateNode, IntermediateNode, prov.loc))
          case TypeConstraint.Provenance.ExpectType(_, _, _) => Some((IntermediateNode, SinkNode, prov.loc))
          case _ => None
        }
        inf.map {
          case (nt1, nt2, loc) =>
            val v1 = toVertex(tpe1, loc, nt1)
            val v2 = toVertex(tpe2, loc, nt2)
            (v1, v2) match {
              case (Nil, _) => return None
              case (_, Nil) => return None
              case (toVertices, fromVertices) =>
                v ++= fromVertices.toSet
                v ++= toVertices.toSet
                flow :::= createEdges(fromVertices, toVertices, prov.loc)
            }
        }
      }
      case _ => ()
    }
    if (flow.isEmpty) return None
    Some(Graph(v.toList, flow))
  }

  private def createEdges(fromVertices: List[Vertex], toVertices: List[Vertex], loc: SourceLocation): List[Edge] = {
    fromVertices.foldLeft(List.empty[Edge]) {
      (acc, from) =>
        toVertices.foldLeft(acc) {
          (acc2, to) => Edge(from, to, loc) :: acc2
        }
    }
  }

  /**
    * Checks if two vertices represent a conflict.
    *
    * Effect variables never conflict with anything since they can unify.
    * All concrete vertices conflict with each other.
    *
    * @param v1 the first vertex, which is a sink node
    * @param v2 the set of vertices flowing into the sink node
    * @return true if the vertices represent a conflict, false otherwise
    */
  private def isConflicting(v1: Vertex, v2: Set[Vertex]): Boolean = {
    v1 match {
      case VarVertex(_) => false
      case SignatureVertex(effs, _) =>
        // all of the effects in the signature must be used:
        val used = effs.forall(e => v2.exists(i => sameType(e, i)))
        // all of the used effects must be in the signature:
        val defined = v2.forall(e => effs.exists(i => sameType(e, i)))
        !used || !defined
      case PureImplicitVertex(_) | PureExplicitVertex(_) => v2.nonEmpty
      case x => !v2.exists(y => sameType(x, y)) || !v2.forall(y => sameType(x, y))
    }

  }

  /**
    * Converts a path to an error if there is a conflict.
    *
    * A conflict occurs when the path starts at an impure vertex and ends at a pure vertex.
    *
    * @param path the path to analyze
    * @return a list containing the error (if any)
    */
  private def mkError(sink: Vertex, incoming: Set[Vertex]): List[EffConflicted] = {
    def kSymToEffSym(sym: Symbol.KindedTypeVarSym): Option[Symbol.EffSym] = sym.text match {
      case VarText.Absent => None
      case VarText.SourceText(s) => Some(Symbol.mkEffSym(s))
    }

    def simpleErrors(v1: Vertex, v2: Vertex): List[EffConflicted] = {
      (v2, v1) match {
        case (IOVertex(loc1), PureImplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ImplicitlyPureFunctionUsesIO(loc2, loc1)))
        case (IOVertex(loc1), PureExplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ExplicitlyPureFunctionUsesIO(loc2, loc1)))
        case (IOVertex(loc1), CstVertex(sym2, loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(sym2), Symbol.IO, loc2, loc1)))
        case (CstVertex(sym1, loc1), IOVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(Symbol.IO), sym1, loc2, loc1)))
        case (CstVertex(sym, loc1), PureExplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ExplicitlyPureFunctionUsesEffect(sym, loc2, loc1)))
        case (CstVertex(sym, loc1), PureImplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ImplicitlyPureFunctionUsesEffect(sym, loc2, loc1)))
        case (CstVertex(sym1, loc1), CstVertex(sym2, loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(sym2), sym1, loc2, loc1)))
        case (IOVertex(loc1), RigidVarVertex(sym, loc2)) =>
          kSymToEffSym(sym) match {
            case None => Nil
            case Some(varSym) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(varSym), Symbol.IO, loc2, loc1)))
          }
        case (CstVertex(sym1, loc1), RigidVarVertex(sym2, loc2)) =>
          kSymToEffSym(sym2) match {
            case None => Nil
            case Some(varSym) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(varSym), sym1, loc2, loc1)))
          }
        case (RigidVarVertex(sym1, loc1), RigidVarVertex(sym2, loc2)) =>
          (kSymToEffSym(sym1), kSymToEffSym(sym2)) match {
            case (Some(effSym), Some(effSym2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(effSym2), effSym, loc2, loc1)))
            case _ => Nil
          }
        case _ => Nil
      }
    }
    (sink, incoming.toList) match {
      case (s@SignatureVertex(effs, sigLoc), xs) =>
        val used = effs.foldLeft(List.empty[Vertex]){
          case(acc, e) => if (!xs.exists(i => sameType(e, i))) e :: acc else acc
        }
        // all of the used effects must be in the signature:
        val defined = xs.foldLeft(List.empty[Vertex]){
          case(acc, e) => if (!effs.exists(i => sameType(e, i))) e :: acc else acc
        }
        val e1: List[EffConflicted] = if (used.nonEmpty) used.flatMap {
          case IOVertex(loc) => Some(TypeConstraint.EffConflicted(TypeError.UnusedEffectInSignature(Symbol.IO, loc)))
          case CstVertex(sym, loc) => Some(TypeConstraint.EffConflicted(TypeError.UnusedEffectInSignature(sym, loc)))
          case RigidVarVertex(sym, loc) => kSymToEffSym(sym).map(
             effSym => TypeConstraint.EffConflicted(TypeError.UnusedEffectInSignature(effSym, loc))
          )
          case _ => None
          } else Nil
        val e2: List[EffConflicted] = if(defined.nonEmpty) defined.flatMap{
          case IOVertex(loc) => Some(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(s.symbols(), Symbol.IO, sigLoc, loc)))
          case CstVertex(sym, loc) => Some(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(s.symbols(), sym, sigLoc, loc)))
          case RigidVarVertex(sym, loc) => kSymToEffSym(sym).map(
            effSym => TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(s.symbols(), effSym, sigLoc, loc))
          )
          case _ => None
        } else Nil
        e1 ++ e2
      case (x, ys) => ys.flatMap(simpleErrors(x, _))
      case _ => Nil
      }
  }

  /**
    * Converts a type to its vertex representation(s).
    *
    * A type may map to multiple vertices (e.g., a union type), a single vertex (e.g. IO),
    * or no vertices (for non-effect types). Returns an empty list if the type
    * cannot be represented as vertices.
    *
    * Examples: IO becomes IOVertex, functions defined to be {} becomes PureExplicitVertex,
    * and PureImplicitVertex in the implicit case.
    *
    * @param tpe      the type to convert
    * @param constLoc the constraint location from where the type was encountered
    * @return the list of vertices representing this type
    */
  private def toVertex(tpe: Type, constLoc: SourceLocation, vtpe: NodeType)(implicit scope: Scope, renv: RigidityEnv): List[Vertex] = tpe match {
    case Type.Var(sym, _) => renv.get(sym) match {
      case Rigidity.Flexible => List(VarVertex(sym))
      case Rigidity.Rigid => List(RigidVarVertex(sym, constLoc))
    }
    case Type.Cst(tc, loc) => tc match {
      case TypeConstructor.Pure => if (loc.isReal) List(PureExplicitVertex(loc)) else List(PureImplicitVertex(constLoc))
      case TypeConstructor.Effect(sym, _) => sym match {
        case Symbol.IO => vtpe match {
          case SinkNode => List(IOVertex(loc))
          case SourceNode | IntermediateNode => List(IOVertex(constLoc))
        }
        case Symbol.Debug => Nil
        case eff => vtpe match {
          case SinkNode => List(CstVertex(eff, loc))
          case SourceNode | IntermediateNode => List(CstVertex(eff, constLoc))
        }
      }
      case _ => List()
    }

    /**
      * The basic pattern for an apply:
      *          Apply
      *          / \
      *         /   \
      *      Apply  tpe2
      *       / \
      *     /    \
      *   Cst    tpe1
      *    |
      *   Op
      */
    case Type.Apply(tpe1, tpe2, _) =>
      val l = (tpe1, tpe2) match {


      /**
        * The "leaf" pattern :
        *           .
        *          / \
        *         /   \
        *      Apply  Var
        *       / \
        *     /    \
        *   Cst    Var
        *    |
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), Type.Var(lSym, _), _), Type.Var(rSym, _)) => tc match {
        case TypeConstructor.Union => List(VarVertex(lSym), VarVertex(rSym))
        case _ => List()
      }

      case (Type.Apply(Type.Cst(tc, _), x@Type.Cst(_, _), _), y@Type.Cst(_, _)) => tc match {
        case TypeConstructor.Union => toVertex(x, constLoc, IntermediateNode) ++ toVertex(y, constLoc, IntermediateNode)
        case _ => List()
      }

      /**
        * The pattern where the right-hand side is nested :
        *           .
        *          / \
        *         /   \
        *      Apply  Apply
        *       / \     ...
        *     /    \
        *   Cst    Var
        *    |
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), Type.Var(lSym, _), _), Type.Apply(_, _, _)) =>
        val rhs = toVertex(tpe2, constLoc, vtpe)
        tc match {
          case TypeConstructor.Union => VarVertex(lSym) :: rhs
          case _ => List()
        }

      /**
        * The pattern where the left-hand side is nested :
        *           .
        *          / \
        *         /   \
        *      Apply  Var
        *       / \
        *     /    \
        *   Cst    Apply
        *    |       ...
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), nested@Type.Apply(_, _, _), _), Type.Var(rSym, _)) =>
        val lhs = toVertex(nested, constLoc, vtpe)
        tc match {
          case TypeConstructor.Union => VarVertex(rSym) :: lhs
          case _ => List()
        }
      case _ => List()
    }
      vtpe match {
        case SinkNode => List(SignatureVertex(l, constLoc))
        case SourceNode | IntermediateNode => l
      }
    case _ => List()
  }
}
