/*
 * Copyright 2026 Alexander Sommer, Samuel Skovbakke
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ca.uwaterloo.flix.language.phase.typer

import ca.uwaterloo.flix.language.ast.shared.{Scope, VarText}
import ca.uwaterloo.flix.language.errors.TypeError
import ca.uwaterloo.flix.language.ast.{Rigidity, RigidityEnv, SourceLocation, Symbol, Type, TypeConstructor}
import ca.uwaterloo.flix.language.phase.typer.EffectProvenance.BFSColor.{Black, Grey, White}
import ca.uwaterloo.flix.language.phase.typer.EffectProvenance.Vertex.{CstVertex, IOVertex, PureExplicitVertex, PureImplicitVertex, RigidVarVertex, VarVertex}
import ca.uwaterloo.flix.language.phase.typer.EffectProvenance.NodeType.{IntermediateNode, SinkNode, SourceNode}
import ca.uwaterloo.flix.language.phase.typer.TypeConstraint.EffConflicted

import scala.annotation.tailrec
import scala.collection.mutable

/**
  * Analyzes constraints generated by ConstraintSolver in order to provide code actions,
  * inlay hints and better error messages.
  *
  * This module constructs a directed graph representing effect flow from type constraints
  * and performs breadth-first search to identify specific paths from effect to another effect.
  * This helps generate specific errors that help with diagnosing effect related errors.
  * It generates lists of all paths from some effect flowing into another (conflicting) effect.
  */
object EffectProvenance {

  /**
    * Color used in BFS search traversal.
    */
  sealed trait BFSColor

  object BFSColor {
    /** Unvisited vertex. */
    case object White extends BFSColor

    /** Vertex in the queue. */
    case object Grey extends BFSColor

    /** Fully processed vertex. */
    case object Black extends BFSColor
  }

  /**
    * Represents a vertex in the BFS with its color and parent information.
    * A parent is vertex u to vertex v is the relation that u flows into v.
    * The parent is set to None in the start, before BFS,
    * and only the starting vertex will not have a parent,
    * i.e. it is the root vertex / starting vertex.
    */
  private case class BFSVertex(vertex: Vertex, color: BFSColor, parent: Option[Vertex]) {
    override def equals(that: Any): Boolean = that match {
      case BFSVertex(v2, _, _) => this.vertex == v2
      case _ => false
    }

    override def hashCode(): Int = vertex.hashCode()
  }

  /**
    * Represents a directed edge in the effect constraint graph.
    */
  private case class Edge(v1: Vertex, v2: Vertex, loc: SourceLocation)

  /**
    * Represents a directed graph of effect flow.
    */
  private case class Graph(vertices: List[Vertex], edges: List[Edge])

  private type MapLattice = Map[Vertex, Set[Vertex]]

  /**
    * Represents a path through the effect constraint graph.
    */
  private type Path = List[Vertex]

  /**
    * Represents a vertex in the effect constraint graph.
    *
    * A Vertex represents one of:
    *   - Explicitly Pure function
    *   - Implicitly Pure function
    *   - The IO effect
    *   - Effect constants, i.e. user-defined effects
    *   - Effect variables
    */
  sealed trait Vertex

  object Vertex {
    /**
      * Explicitly Pure function (has a real source location).
      *
      * Example: def foo(): Unit \ {} = ()
      *
      * @param loc the source location of {}
      */
    case class PureExplicitVertex(loc: SourceLocation) extends Vertex

    /**
      * Implicitly Pure function.
      *
      * Example: def foo(): Unit = ()
      *
      * @param loc the synthetic location, which is the position immediately to the right of the return type.
      */
    case class PureImplicitVertex(loc: SourceLocation) extends Vertex

    /**
      * User-defined effect.
      *
      * @param sym the effect symbol
      * @param loc the source location where the effect is called
      */
    case class CstVertex(sym: Symbol.EffSym, loc: SourceLocation) extends Vertex

    /**
      * The IO effect.
      *
      * @param loc the source location where IO is called
      */
    case class IOVertex(loc: SourceLocation) extends Vertex

    /**
      * A rigid effect variable
      *
      * @param sym the effect variable symbol
      * @param loc the location of the rigid effect variable
      */
    case class RigidVarVertex(sym: Symbol.KindedTypeVarSym, loc: SourceLocation) extends Vertex

    /**
      * Effect variable.
      *
      * @param sym the effect variable symbol
      */
    case class VarVertex(sym: Symbol.KindedTypeVarSym) extends Vertex
  }

  /**
    * Represents the type of node constructed in the effect provenance graph
    *
    * This trait allows to differentiate between two Vertices of the same type, differently, determined by the NodeType
    *
    * For example an IO Vertex in a signature, e.g. f(): Unit \ IO
    * is constructed differently than one that appears in a source node. e.g. println("42")
    *
    * This trait is only used when constructing the graph
    */
  sealed trait NodeType

  object NodeType {
    case object SinkNode extends NodeType

    case object IntermediateNode extends NodeType

    case object SourceNode extends NodeType
  }

  /**
    * Builds an effect conflict graph from given constraints.
    * Then analyzes the effect conflict graph and returns a list of effect conflicts.
    *
    * Returns a list of effect conflicts if any are found, or None if no good effect error could be made.
    * A conflict is: a path from an effect to a differing effect. E.g. IO -> ... -> {}.
    * This is the main entry point for effect provenance analysis.
    *
    * @param constrs0 the list of type constraints to analyze
    * @return a list of conflicts if conflicts could be found, None otherwise
    */
  def getErrors(constrs0: List[TypeConstraint])(implicit scope: Scope, renv: RigidityEnv): Option[List[EffConflicted]] = {
    val graph = buildGraph(constrs0)
    graph.flatMap(analysis)
  }

  private def analysis(graph: Graph): Option[List[EffConflicted]] = {
    def helper(ml: MapLattice): MapLattice = {
      graph.edges.foldLeft(ml) {
        case (acc, Edge(from, to, _)) =>
          val f = acc.get((from))
          val t = acc.get((to))
          f match {
            case None => t match {
              case Some(ys) => acc + (to -> (ys))
              case None => acc + (to -> Set(from))
            }
            case Some(xs) => t match {
              case Some(ys) => acc + (to -> (ys ++ xs))
              case None => acc + (to -> xs)
            }

          }
      }
    }

    var fp = helper(Map.empty: MapLattice)
    while (fp != helper(fp)) {
      fp = helper(fp)
    }
    val res = fp.foldLeft(List.empty[EffConflicted]) {
      case (acc, (v, vs)) => vs.foldLeft(acc) {
        case (acc2, x) => if (isConflicting(x, v)) mkError(x, v) ::: acc2 else acc2
      }
    }
    if (res.isEmpty) None else Some(res)
  }

  /**
    * Constructs an effect provenance graph from type constraints.
    *
    * The graph represents flow of effects through the program. An edge from A to B
    * means that effect A flows to B.
    *
    * @param constraints the type constraints to analyze
    * @return Some(graph) if one or more edges could be created, otherwise None
    */
  private def buildGraph(constraints: List[TypeConstraint])(implicit scope: Scope, renv: RigidityEnv): Option[Graph] = {
    var flow: List[Edge] = List()
    var v: Set[Vertex] = Set.empty
    constraints.foreach {
      case TypeConstraint.Equality(tpe1, tpe2, prov) => {
        val inf = prov match {
          case TypeConstraint.Provenance.ExpectEffect(_, _, _) => Some((SinkNode, IntermediateNode, prov.loc))
          case TypeConstraint.Provenance.Source(_, _, _) => Some((IntermediateNode, SourceNode, prov.loc))
          case TypeConstraint.Provenance.Match(_, _, _) => Some((IntermediateNode, IntermediateNode, prov.loc))
          case TypeConstraint.Provenance.ExpectType(_, _, _) => Some((IntermediateNode, SinkNode, prov.loc))
          case _ => None
        }
        inf.map {
          case (nt1, nt2, loc) =>
            val v1 = toVertex(tpe1, loc, nt1)
            val v2 = toVertex(tpe2, loc, nt2)
            (v1, v2) match {
              case (Nil, _) => return None
              case (_, Nil) => return None
              case (toVertices, fromVertices) =>
                v ++= fromVertices.toSet
                v ++= toVertices.toSet
                flow :::= createEdges(fromVertices, toVertices, prov.loc)
            }
        }
      }
      case _ => ()
    }
    if (flow.isEmpty) return None
    Some(Graph(v.toList, flow))
  }

  private def createEdges(fromVertices: List[Vertex], toVertices: List[Vertex], loc: SourceLocation): List[Edge] = {
    fromVertices.foldLeft(List.empty[Edge]) {
      (acc, from) =>
        toVertices.foldLeft(acc) {
          (acc2, to) => Edge(from, to, loc) :: acc2
        }
    }
  }

  /**
    * Checks if two vertices represent a conflict.
    *
    * Effect variables never conflict with anything since they can unify.
    * All concrete vertices conflict with each other.
    *
    * @param v1 the first vertex
    * @param v2 the second vertex
    * @return true if the vertices represent a conflict, false otherwise
    */
  private def isConflicting(v1: Vertex, v2: Vertex): Boolean = (v1, v2) match {
    case (_, VarVertex(_)) => false
    case (VarVertex(_), _) => false
    case (RigidVarVertex(_, _), RigidVarVertex(_, _)) => v1 != v2
    case (CstVertex(sym1, _), CstVertex(sym2, _)) => sym1 != sym2
    case (_, _) => true
  }

  /**
    * Converts a path to an error if there is a conflict.
    *
    * A conflict occurs when the path starts at an impure vertex and ends at a pure vertex.
    *
    * @param path the path to analyze
    * @return a list containing the error (if any)
    */
  private def mkError(v1: Vertex, v2: Vertex): List[EffConflicted] = {
    def kSymToEffSym(sym: Symbol.KindedTypeVarSym): Option[Symbol.EffSym] = sym.text match {
      case VarText.Absent => None
      case VarText.SourceText(s) => Some(Symbol.mkEffSym(s))
    }

    (v1, v2) match {
      case (IOVertex(loc1), PureImplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ImplicitlyPureFunctionUsesIO(loc2, loc1)))
      case (IOVertex(loc1), PureExplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ExplicitlyPureFunctionUsesIO(loc2, loc1)))
      case (IOVertex(loc1), CstVertex(sym2, loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(sym2), Symbol.IO, loc2, loc1)))
      case (CstVertex(sym1, loc1), IOVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(Symbol.IO), sym1, loc2, loc1)))
      case (CstVertex(sym, loc1), PureExplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ExplicitlyPureFunctionUsesEffect(sym, loc2, loc1)))
      case (CstVertex(sym, loc1), PureImplicitVertex(loc2)) => List(TypeConstraint.EffConflicted(TypeError.ImplicitlyPureFunctionUsesEffect(sym, loc2, loc1)))
      case (CstVertex(sym1, loc1), CstVertex(sym2, loc2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(sym2), sym1, loc2, loc1)))
      case (IOVertex(loc1), RigidVarVertex(sym, loc2)) =>
        kSymToEffSym(sym) match {
          case None => Nil
          case Some(varSym) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(varSym), Symbol.IO, loc2, loc1)))
        }
      case (CstVertex(sym1, loc1), RigidVarVertex(sym2, loc2)) =>
        kSymToEffSym(sym2) match {
          case None => Nil
          case Some(varSym) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(varSym), sym1, loc2, loc1)))
        }
      case (RigidVarVertex(sym1, loc1), RigidVarVertex(sym2, loc2)) =>
        (kSymToEffSym(sym1), kSymToEffSym(sym2)) match {
          case (Some(effSym), Some(effSym2)) => List(TypeConstraint.EffConflicted(TypeError.EffectfulFunctionUsesOtherEffect(List(effSym2), effSym, loc2, loc1)))
          case _ => Nil
        }
      case _ => Nil
    }
  }

  /**
    * Converts a type to its vertex representation(s).
    *
    * A type may map to multiple vertices (e.g., a union type), a single vertex (e.g. IO),
    * or no vertices (for non-effect types). Returns an empty list if the type
    * cannot be represented as vertices.
    *
    * Examples: IO becomes IOVertex, functions defined to be {} becomes PureExplicitVertex,
    * and PureImplicitVertex in the implicit case.
    *
    * @param tpe      the type to convert
    * @param constLoc the constraint location from where the type was encountered
    * @return the list of vertices representing this type
    */
  private def toVertex(tpe: Type, constLoc: SourceLocation, vtpe: NodeType)(implicit scope: Scope, renv: RigidityEnv): List[Vertex] = tpe match {
    case Type.Var(sym, _) => renv.get(sym) match {
      case Rigidity.Flexible => List(VarVertex(sym))
      case Rigidity.Rigid => List(RigidVarVertex(sym, constLoc))
    }
    case Type.Cst(tc, loc) => tc match {
      case TypeConstructor.Pure => if (loc.isReal) List(PureExplicitVertex(loc)) else List(PureImplicitVertex(constLoc))
      case TypeConstructor.Effect(sym, _) => sym match {
        case Symbol.IO => vtpe match {
          case SinkNode => List(IOVertex(loc))
          case SourceNode | IntermediateNode => List(IOVertex(constLoc))
        }
        case Symbol.Debug => Nil
        case eff => vtpe match {
          case SinkNode => List(CstVertex(eff, loc))
          case SourceNode | IntermediateNode => List(CstVertex(eff, constLoc))
        }
      }
      case _ => List()
    }

    /**
      * The basic pattern for an apply:
      *          Apply
      *          / \
      *         /   \
      *      Apply  tpe2
      *       / \
      *     /    \
      *   Cst    tpe1
      *    |
      *   Op
      */
    case Type.Apply(tpe1, tpe2, _) => (tpe1, tpe2) match {


      /**
        * The "leaf" pattern :
        *           .
        *          / \
        *         /   \
        *      Apply  Var
        *       / \
        *     /    \
        *   Cst    Var
        *    |
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), Type.Var(lSym, _), _), Type.Var(rSym, _)) => tc match {
        case TypeConstructor.Union => List(VarVertex(lSym), VarVertex(rSym))
        case _ => List()
      }

      /**
        * The pattern where the right-hand side is nested :
        *           .
        *          / \
        *         /   \
        *      Apply  Apply
        *       / \     ...
        *     /    \
        *   Cst    Var
        *    |
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), Type.Var(lSym, _), _), Type.Apply(_, _, _)) =>
        val rhs = toVertex(tpe2, constLoc, vtpe)
        tc match {
          case TypeConstructor.Union => VarVertex(lSym) :: rhs
          case _ => List()
        }

      /**
        * The pattern where the left-hand side is nested :
        *           .
        *          / \
        *         /   \
        *      Apply  Var
        *       / \
        *     /    \
        *   Cst    Apply
        *    |       ...
        *   Op
        */
      case (Type.Apply(Type.Cst(tc, _), nested@Type.Apply(_, _, _), _), Type.Var(rSym, _)) =>
        val lhs = toVertex(nested, constLoc, vtpe)
        tc match {
          case TypeConstructor.Union => VarVertex(rSym) :: lhs
          case _ => List()
        }
      case _ => List()
    }
    case _ => List()
  }
}
