/*
 * Copyright 2019 Magnus Madsen, Stephen Tetley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace Array {

    ///
    /// Compares `a` and `b` lexicographically.
    ///
    pub def compare(a: Array[v, r1], b: Array[v, r2]): Comparison \ Read(r1, r2) with Order[v] =
        let len = Int32.min(Array.length(a), Array.length(b));
        def loop(i) = {
            if (i < len) {
                let cmp = a[i] <=> b[i];
                if (cmp == Comparison.EqualTo)
                    loop(i + 1)
                else
                    cmp
            } else if (i < Array.length(a)) {
                Comparison.GreaterThan
            } else if (i < Array.length(b)) {
                Comparison.LessThan
            } else {
                Comparison.EqualTo
            }
        };
        loop(0)

    ///
    /// Returns a string representation of the given array `a`.
    ///
    pub def toString(a: Array[a, r]): String \ Read(r) with ToString[a] = region r2 {
        let sb = new StringBuilder(r2);
        let first = ref true @ r2;

        StringBuilder.appendString!("Array#{", sb);

        let f = (x) -> {
            if (not deref first) StringBuilder.appendString!(", ", sb) else first := false;
            StringBuilder.appendString!("${x}", sb)
        };
        forEach(f, a);

        StringBuilder.appendString!("}", sb);
        StringBuilder.toString(sb)
    }

    ///
    /// Returns a new uninitialized array of length `l` in the region `r`.
    ///
    pub def new(r: Region[r], l: Int32): Array[a, r] \ Write(r) =
        $ARRAY_NEW$(r, Reflect.default(), l)

    ///
    /// Retrieves the value at position `i` in the array `a`.
    ///
    pub def get(i: Int32, a: Array[a, r]): a \ Read(r) =
        a[i]

    ///
    /// Stores the value `x` at position `i` in the array `a`.
    ///
    pub def put(x: a, i: Int32, a: Array[a, r]): Unit \ Write(r) =
        a[i] = x

    ///
    /// Optionally returns the element at position `i` in the array `a`.
    ///
    pub def nth(i: Int32, a: Array[a, r]): Option[a] \ Read(r) =
        if (0 <= i and i < length(a))
            Some(a[i])
        else
            None

    ///
    /// Returns `true` if the given array `a` is empty.
    ///
    pub def isEmpty(a: Array[a, r]): Bool = length(a) == 0

    ///
    /// Returns the length of the array `a`.
    ///
    pub def length(a: Array[a, r]): Int32 = $ARRAY_LENGTH$(a)

    ///
    /// Returns a fresh array with the elements from the array `a` from index `start` (inclusive) until index `end` (exclusive).
    ///
    pub def slice(r1: Region[r1], start: {start = Int32}, end: {end = Int32}, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        $ARRAY_SLICE$(r1, a, start.start, end.end)

    ///
    /// Returns the array `a` as a list.
    ///
    pub def toList(a: Array[a, r]): List[a] \ Read(r) =
        def loop(i, acc) = {
            if (i == 0) {
                acc
            } else {
                let x = a[i - 1];
                loop(i - 1, x :: acc)
            }
        };
        loop(length(a), Nil)

    ///
    /// Optionally returns the array `arr` as a non-empty list.
    ///
    /// If `arr` is empty return `None`, otherwise return the Nel wrapped in `Some`.
    ///
    pub def toNel(arr: Array[a, r]): Option[Nel[a]] \ Read(r) =
        def loop(i, acc) = {
            if (i == 0) {
                acc
            } else {
                let x = arr[i - 1];
                loop(i - 1, Nel.cons(x, acc))
            }
        };
        if (Array.isEmpty(arr)) {
            None
        } else {
            let i = length(arr) - 1;
            Some(loop(i, Nel.singleton(arr[i])))
        }

    ///
    /// Returns the array `a` as a `DelayList`.
    ///
    pub def toDelayList(a: Array[a, r]): DelayList[a] \ Read(r) =
        def loop(i, acc) = {
            if (i < 0)
                acc
            else
                loop(i - 1, DelayList.ECons(a[i], acc))
        };
        loop(length(a) - 1, DelayList.ENil)

    ///
    /// Returns the array `arr` as a chain.
    ///
    pub def toChain(arr: Array[a, r]): Chain[a] \ Read(r) =
        def loop(i, acc) = {
            if (i == 0) {
                acc
            } else {
                let x = arr[i - 1];
                loop(i - 1, Chain.cons(x, acc))
            }
        };
        loop(length(arr), Chain.empty())

    ///
    /// Optionally returns the array `arr` as a non-empty chain.
    ///
    /// If `arr` is empty return `None`, otherwise return the Nec wrapped in `Some`.
    ///
    pub def toNec(arr: Array[a, r]): Option[Nec[a]] \ Read(r) =
        def loop(i, acc) = {
            if (i == 0) {
                acc
            } else {
                let x = arr[i - 1];
                loop(i - 1, Nec.cons(x, acc))
            }
        };
        if (Array.isEmpty(arr)) {
            None
        } else {
            let i = length(arr) - 1;
            Some(loop(i, Nec.singleton(arr[i])))
        }

    ///
    /// Returns `a` as a MutDeque.
    ///
    pub def toMutDeque(r1: Region[r1], a: Array[a, r2]): MutDeque[a, r1] \ { Read(r2), Write(r1) }  =
        let d = new MutDeque(r1);
        forEach(x -> MutDeque.pushBack(x, d), a);
        d

    ///
    /// Returns `a` as a Vector.
    ///
    pub def toVector(a: Array[a, r]): Vector[a] \ Read(r) = region rc {
        let arr1 = copyOfRange(rc, 0, length(a), a);
        unsafe_cast arr1 as Vector[a]
    }

    ///
    /// Returns `Some(x)` if `x` is the first element of `a`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def head(a: Array[a, r]): Option[a] \ Read(r) =
        if (length(a) > 0) Some(a[0]) else None

    ///
    /// Returns `Some(x)` if `x` is the last element of `a`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def last(a: Array[a, r]): Option[a] \ Read(r) =
        let len = length(a);
        if (len > 0) Some(a[len-1]) else None

    ///
    /// Return a new array, appending the elements `b` to elements of `a`.
    ///
    pub def append(r3: Region[r3], a: Array[a, r1], b: Array[a, r2]): Array[a, r3] \ { Read(r1), Read(r2), Write(r3) } =
        let len1 = length(a);
        let len2 = length(b);
        if (len1 == 0)
            copyOfRange(r3, 0, len2, b)
        else {
            let out = copyOfRange(r3, 0, len1 + len2, a);
            updateSequence!(len1, b, out);
            out
        }

    ///
    /// Returns `true` if and only if `a` contains the element `x`.
    ///
    pub def memberOf(x: a, a: Array[a, r]): Bool \ Read(r) with Eq[a] =
        exists(y -> y == x, a)

    ///
    /// Optionally finds the smallest element of `a` according to the `Order` on `a`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def minimum(a: Array[a, r]): Option[a] \ Read(r) with Order[a] =
        reduceLeft(Order.min, a)

    ///
    /// Optionally finds the smallest element of `a` according to the given comparator `cmp`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def minimumBy(cmp: (a, a) -> Comparison, a: Array[a, r]): Option[a] \ Read(r) =
        reduceLeft(Order.minBy(cmp), a)

    ///
    /// Optionally finds the largest element of `a` according to the `Order` on `a`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def maximum(a: Array[a, r]): Option[a] \ Read(r) with Order[a] =
        reduceLeft(Order.max, a)

    ///
    /// Optionally finds the largest element of `a` according to the given comparator `cmp`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def maximumBy(cmp: (a, a) -> Comparison, a: Array[a, r]): Option[a] \ Read(r) =
        reduceLeft(Order.maxBy(cmp), a)

    ///
    /// Alias for `IndexOfLeft`
    ///
    pub def indexOf(x: a, a: Array[a, r]): Option[Int32] \ Read(r) with Eq[a] =
        indexOfLeft(x,a)

    ///
    /// Optionally returns the position of the first occurrence of `a` in `arr`
    /// searching from left to right.
    ///
    pub def indexOfLeft(a: a, arr: Array[a, r]): Option[Int32] \ Read(r) with Eq[a] =
        def loop(i) = {
            if (i >= length(arr))
                -1
            else if (arr[i] == a)
                i
            else
                loop(i + 1)
        };
        let i = loop(0);
        if (i < 0) None else Some(i)

    ///
    /// Optionally returns the position of the first occurrence of `a` in `arr`
    /// searching from right to left.
    ///
    pub def indexOfRight(a: a, arr: Array[a, r]): Option[Int32] \ Read(r) with Eq[a] =
        def loop(i) = {
            if (i < 0)
                -1
            else if (arr[i] == a)
                i
            else
                loop(i - 1)
        };
        let i = loop(length(arr) - 1);
        if (i < 0) None else Some(i)

    ///
    /// Return the positions of the all the occurrences of `a` in `arr`.
    ///
    pub def indices(r: Region[r], a: a, arr: Array[a, r]): Array[Int32, r] \ { Read(r), Write(r) } with Eq[a] =
        findIndices(r, b -> a == b, arr)

    ///
    /// Alias for `findLeft`.
    ///
    pub def find(f: a -> Bool \ ef, arr: Array[a, r]): Option[a] \ { ef, Read(r) } =
        findLeft(f, arr)

    ///
    /// Optionally returns the first element of `a` that satisfies the predicate `f` when searching from left to right.
    ///
    pub def findLeft(f: a -> Bool \ ef, arr: Array[a, r]): Option[a] \ { ef, Read(r) } =
        match findIndexOfLeft(f, arr) {
            case None    => None
            case Some(i) => Some(arr[i])
        }

    ///
    /// Optionally returns the first element of `xs` that satisfies the predicate `f` when searching from right to left.
    ///
    pub def findRight(f: a -> Bool \ ef, arr: Array[a, r]): Option[a] \ { ef, Read(r) } =
        match findIndexOfRight(x -> f(x), arr) {
            case None    => None
            case Some(i) => Some(arr[i])
        }

    ///
    /// Returns an array of all integers between `b` (inclusive) and `e` (exclusive).
    ///
    /// Returns `[]` if `b >= e`.
    ///
    pub def range(r: Region[r], b: Int32, e: Int32): Array[Int32, r] \ Write(r) =
        if (b >= e)
            Array#{} @ r
        else {
            let f = x -> x + b;
            init(r, f, e - b)
        }

    ///
    /// Returns an array with the element `x` repeated `n` times.
    ///
    /// Returns the empty array if `n <= 0`.
    ///
    pub def repeat(r: Region[r], n: Int32, x: a): Array[a, r] \ Write(r) =
        if (n <= 0)
            Array#{} @ r
        else
            $ARRAY_NEW$(r, x, n)

    ///
    /// Alias for `scanLeft`.
    ///
    pub def scan(r: Region[r], f: (b, a) -> b \ ef, s: b, arr: Array[a, r]): Array[b, r] \ { ef, Read(r), Write(r) } =
        scanLeft(r, f, s, arr)

    ///
    /// Accumulates the result of applying `f` to `arr` going left to right.
    ///
    /// That is, the result is of the form: `[s , f(s, x1), f(f(s, x1), x2),  ...]`.
    ///
    pub def scanLeft(r: Region[r], f: (b, a) -> b \ ef, s: b, arr: Array[a, r]): Array[b, r] \ { ef, Read(r), Write(r) } =
        let len = length(arr) + 1;
        let b = repeat(r, len, s);
        def loop(i, acc) = {
            if (i >= len)
                ()
            else {
                let s1 = f(acc, arr[i - 1]);
                b[i] = s1;
                loop(i + 1, s1)
            }
        };
        loop(1, s);
        b

    ///
    /// Accumulates the result of applying `f` to `xs` going right to left.
    ///
    /// That is, the result is of the form: `[..., f(xn-1, f(xn, s)), f(xn, s), s]`.
    ///
    pub def scanRight(r: Region[r], f: (a, b) -> b \ ef, s: b, a: Array[a, r]): Array[b, r] \ { ef, Read(r), Write(r) } =
        let len = length(a);
        let b = repeat(r, len + 1, s);
        def loop(i, acc) = {
            if (i < 0)
                ()
            else {
                let s1 = f(a[i], acc);
                b[i] = s1;
                loop(i - 1, s1)
            }
        };
        loop(len - 1, s);
        b

    ///
    /// Returns the result of applying `f` to every element in `a`.
    ///
    /// The result is a new array.
    ///
    pub def map(r1: Region[r1], f: a -> b \ ef, a: Array[a, r]): Array[b, r1] \ { ef, Read(r), Write(r1) } =
        let len = length(a);
        init(r1, i -> f(a[i]), len)

    ///
    /// Apply `f` to every element in array `arr`. Array `arr` is mutated.
    ///
    pub def transform!(f: a -> a \ ef, arr: Array[a, r]): Unit \ { ef, Read(r), Write(r) } =
        let len = length(arr);
        def loop(i) = {
            if (i >= len)
                ()
            else {
                arr[i] = f(arr[i]);
                loop(i + 1)
            }
        };
        loop(0)

    ///
    /// Returns the result of applying `f` to every element in `a` along with that element's index.
    ///
    /// That is, the result is of the form: `[ f(a[0], 0), f(a[1], 1), ... ]`.
    ///
    pub def mapWithIndex(r1: Region[r1], f: (Int32, a) -> b \ ef, a: Array[a, r]): Array[b, r1] \ { ef, Read(r), Write(r1) } =
        let len = length(a);
        init(r1, i -> f(i, a[i]), len)

    ///
    /// Apply `f` to every element in array `a` along with that element's index. Array `a` is mutated.
    ///
    pub def transformWithIndex!(f: (Int32, a) -> a \ ef, arr: Array[a, r]): Unit \ { ef, Read(r), Write(r) } =
        let len = length(arr);
        def loop(i) = {
            if (i >= len)
                ()
            else {
                arr[i] = f(i, arr[i]);
                loop(i + 1)
            }
        };
        loop(0)

    ///
    /// Returns the result of applying `f` to every element in `a` and concatenating the results.
    ///
    pub def flatMap(r1: Region[r1], f: a -> Array[b, r1] \ ef, a: Array[a, r]): Array[b, r1] \ { ef, Read(r), Write(r1) } =
        let len = length(a);
        init(r1, i -> f(a[i]), len) |> flatten(r1)

    ///
    /// Returns the reverse of `a`.
    ///
    pub def reverse(r1: Region[r1], a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let len = length(a);
        let end = len - 1;
        init(r1, i -> a[end - i], len)

    ///
    /// Reverse the array `arr`, mutating it in place.
    ///
    pub def reverse!(arr: Array[a, r]): Unit \ { Read(r), Write(r) } =
        let len = length(arr);
        let halflen = len / 2;
        def loop(i, j) = {
            if (i >= halflen)
                ()
            else {
                let x = arr[i];
                let y = arr[j];
                put(y, i, arr);
                put(x, j, arr);
                loop(i + 1, j - 1)
            }
        };
        loop(0, len - 1)

    ///
    /// Rotate the contents of array `arr` by `n` steps to the left.
    ///
    pub def rotateLeft(r2: Region[r2], n: Int32, arr: Array[a, r1]): Array[a, r2] \ { Read(r1), Write(r2) } =
        let len = length(arr);
        if (len < 1)
            Array#{} @ r2
        else
            if (n < 0)
                rotateRightHelper(r2, Int32.abs(n), arr)
            else
                rotateLeftHelper(r2, n, arr)

    ///
    /// Helper function for `rotateLeft` and `rotateRight`.
    ///
    /// Precondition: `n` must be positive.
    ///
    /// This is an explicit helper to avoid code duplication.
    ///
    def rotateLeftHelper(r2: Region[r2], n: Int32, arr: Array[a, r1]): Array[a, r2] \ { Read(r1), Write(r2) } =
        let len = length(arr);
        let f = i -> { let i1 = n + i; arr[i1 `Int32.rem` len] };
        init(r2, f, len)

    ///
    /// Rotate the contents of array `arr` by `n` steps to the right.
    ///
    pub def rotateRight(r2: Region[r2], n: Int32, arr: Array[a, r1]): Array[a, r2] \ { Read(r1), Write(r2) } =
        if (length(arr) < 1)
            Array#{} @ r2
        else
            if (n < 0)
                rotateLeftHelper(r2, Int32.abs(n), arr)
            else
                rotateRightHelper(r2, n, arr)

    ///
    /// Helper function for `rotateRight` and `rotateLeft`.
    ///
    /// Precondition: `n` must be positive.
    ///
    /// This is an explicit helper to avoid code duplication.
    ///
    def rotateRightHelper(r2: Region[r2], n: Int32, a: Array[a, r1]): Array[a, r2] \ { Read(r1), Write(r2) } =
        let len = length(a);
        let n1 = n `Int32.rem` len;
        let start = len - n1;
        let f = i -> { let i1 = start + i; a[i1 `Int32.rem` len]};
        init(r2, f, len)

    ///
    /// Returns a copy of `a` with the element at index `i` replaced by `x`.
    ///
    /// Returns a shallow copy of `a` if `i < 0` or `i > length(xs)-1`.
    ///
    pub def update(r1: Region[r1], i: Int32, x: a, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let len = length(a);
        let f = ix -> if (ix == i) x else a[ix];
        init(r1, f, len)

    ///
    /// Returns a copy of `a` with every occurrence of `from` replaced by `to`.
    ///
    pub def replace(r1: Region[r1], from: {from = a}, to: {to = a}, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } with Eq[a] =
        map(r1, e -> if (e == from.from) to.to else e, a)

    ///
    /// Replace every occurrence of `from` by `to` in the array `a`, mutating it in place.
    ///
    pub def replace!(from: {from = a}, to: {to = a}, a: Array[a, r]): Unit \ { Read(r), Write(r) } with Eq[a] =
        transform!(e -> if (e == from.from) to.to else e, a)

    ///
    /// Returns `b` with the `n` elements starting at index `i` replaced with the elements of `a`.
    ///
    /// If any of the indices `i, i+1, i+2, ... , i+n-1` are out of range in `b` then no patching is done at these indices.
    /// If `a` becomes depleted then no further patching is done.
    /// If patching occurs at index `i+j` in `b`, then the element at index `j` in `a` is used.
    ///
    pub def patch(r3: Region[r3], i: Int32, n: Int32, a: Array[a, r1], b: Array[a, r2]): Array[a, r3] \ { Read(r1, r2), Write(r3) } =
        let len1 = length(a);
        let size = if (n > len1) len1 else n;
        let sub = copyOfRange(r3, 0, size, a);
        updateSequence(r3, i, sub, b)

    ///
    /// Update the mutable array `b` replacing `n` elements starting at index `i` with the corresponding elements of array `a`.
    ///
    /// If any of the indices `i, i+1, i+2, ... , i+n-1` are out of range in `b` then no patching is done at these indices.
    /// If `a` becomes depleted then no further patching is done.
    /// If patching occurs at index `i+j` in `b`, then the element at index `j` in `a` is used.
    ///
    pub def patch!(i: Int32, n: Int32, a: Array[a, r1], b: Array[a, r2]): Unit \ { Read(r1), Write(r2) } = region r3 {
        let len1 = length(a);
        let size = if (n > len1) len1 else n;
        let sub = copyOfRange(r3, 0, size, a);
        updateSequence!(i, sub, b)
    }

    ///
    /// Returns `a` with `x` inserted between every two adjacent elements.
    ///
    pub def intersperse(r1: Region[r1], x: a, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) }=
        let len1 = length(a);
        let len2 = len1 + len1 - 1;
        if (len2 <= 0)
            Array#{} @ r1
        else {
            let b = repeat(r1, len2, x);
            let f = { (i, v) -> let j = i + i; b[j] = v };
            forEachWithIndex(f, a);
            b
        }

    ///
    /// Returns the concatenation of the elements in `arrs` with the elements of `sep` inserted between every two adjacent elements.
    ///
    pub def intercalate(r1: Region[r1], sep: Array[a, r], arrs: Array[Array[a, r], r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let count = length(arrs);
        let sepLength = length(sep);
        let sepCount = if (count < 2) 0 else count - 1;
        let len = sumLengths(arrs) + (sepCount * sepLength);
        match headArrays(arrs) {
            case None    => Array#{} @ r1
            case Some(x) =>
                let out = repeat(r1, len, x);
                let overwrite = { (st, a) ->
                    let (pos,i) = st;
                    if (i == 0) {
                        let pos1 = arrayWrites(0, a, out);
                        (pos1, 1)
                    } else {
                        let pos1 = arrayWrites(pos, sep, out);
                        let pos2 = arrayWrites(pos1, a, out);
                        (pos2, i+1)
                    }};
                discard foldLeft(overwrite, (0, 0), arrs);
                out
        }

    ///
    /// Imperatively write `sub` at position `pos` in array `out`
    ///
    /// Return the new write position which is `pos + length(sub)`.
    ///
    /// Helper function for `intercalate` which needs to do sucessive writing.
    ///
    def arrayWrites(pos: Int32, sub: Array[a, r1], out: Array[a, r2]): Int32 \ { Read(r1), Write(r2) } =
        updateSequence!(pos, sub, out);
        pos + length(sub)

    ///
    /// Sum the lengths of an array of arrays.
    ///
    /// Helper function for `intercalate` and `flatten`.
    ///
    def sumLengths(arrs: Array[Array[a, r1], r2]): Int32 \ Read(r2) =
        foldLeft((acc, a) -> acc + length(a), 0, arrs)

    ///
    /// Find the first non-empty array of an array of arrays (left-to-right).
    ///
    /// Helper function for `intercalate` and `flatten`.
    ///
    def headArrays(arrs: Array[Array[a, r1], r2]): Option[a] \ Read(r1, r2) =
        let len = length(arrs);
        def loop(i) = {
            if (i >= len)
                None
            else
                match head(arrs[i]) {
                    case Some(x) => Some(x)
                    case None    => loop(i + 1)
                }
        };
        loop(0)

    ///
    /// Returns the transpose of `a`.
    ///
    /// Returns `a` if the dimensions of the elements of `a` are mismatched.
    ///
    pub def transpose(r3: Region[r3], a: Array[Array[a, r1], r2]): Array[Array[a, r3], r3] \ { Read(r1, r2), Write(r3) } =
        let ilen = length(a);
        if (ilen == 0)
            Array#{} @ r3
        else {
            let jlen = length(a[0]);
            if (jlen == 0 or uniformHelper(a, jlen))
                // Non-transposing nested copy
                init(r3, i -> copyOfRange(r3, 0, length(a[i]), a[i]), ilen)
            else
                init(r3, i -> init(r3, j -> a[j][i], ilen), jlen)
        }

    ///
    /// Helper function for `transpose`.
    ///
    def uniformHelper(a: Array[Array[a, r1], r2], l: Int32): Bool \ Read(r2) =
        exists(x -> length(x) != l, a)

    ///
    /// Returns `true` if and only if `a1` is a prefix of `a2`.
    ///
    pub def isPrefixOf(a1: Array[a, r1], a2: Array[a, r2]): Bool \ Read(r1, r2) with Eq[a] =
        let len1 = length(a1);
        if (len1 > length(a2))
            false
        else
            def loop(i) = {
                if (i >= len1)
                    true
                else if (a1[i] != a2[i])
                    false
                else
                    loop(i + 1)
            };
            loop(0)

    ///
    /// Returns `true` if and only if `a1` is a infix of `a2`.
    ///
    pub def isInfixOf(a1: Array[a, r1], a2: Array[a, r2]): Bool \ Read(r1, r2) with Eq[a] =
        let len1 = length(a1);
        let len2 = length(a2);
        if (len1 > len2)
            false
        else if (len1 == 0)
            true
        else
            isInfixOfSearch(a1, a2, len1, len2, 0)

    ///
    /// Helper function for `isInfixOf` - scan a2 to find a match with first element of a1.
    ///
    /// Precondition: len1 (length of a1) > 0
    ///
    def isInfixOfSearch(a1: Array[a, r1], a2: Array[a, r2], len1: Int32, len2: Int32, j: Int32): Bool \ Read(r1, r2) with Eq[a] =
        if (j >= len2)
            false
        else if (a1[0] == a2[j])
            isInfixOfCheck(a1, a2, len1, len2, 1, j+1)
        else
            isInfixOfSearch(a1, a2, len1, len2, j+1)

    ///
    /// Helper function for `isInfixOf` - a1 has started matching, scan to see if it all matches.
    ///
    def isInfixOfCheck(a1: Array[a, r1], a2: Array[a, r2], len1: Int32, len2: Int32, i: Int32, j: Int32): Bool \ Read(r1, r2) with Eq[a] =
        if (i >= len1)
            // a1 exhausted, so success
            true
        else if (j >= len2)
            // a2 exhausted, a1 still trying to match, so failure
            false
        else if(a1[i] == a2[j])
            isInfixOfCheck(a1, a2, len1, len2, i+1, j+1)
        else
            isInfixOfSearch(a1, a2, len1, len2, j+1)

    ///
    /// Returns `true` if and only if `a1` is a suffix of `a2`.
    ///
    pub def isSuffixOf(a1: Array[a, r1], a2: Array[a, r2]): Bool \ Read(r1, r2) with Eq[a] =
        let len1 = length(a1);
        let len2 = length(a2);
        if (len1 > len2)
            false
        else
            def loop(i, j) = {
                if (i < 0)
                    true
                else if (a1[i] != a2[j])
                    false
                else
                    loop(i - 1, j - 1)
            };
            loop(len1 - 1, len2 - 1)

    ///
    /// Returns the result of applying `combine` to all the elements in `a`, using `empty` as the initial value.
    ///
    pub def fold(arr: Array[a, r]): a \ Read(r) with Monoid[a] = foldLeft(Monoid.combine, Monoid.empty(), arr)

    ///
    /// Applies `f` to a start value `s` and all elements in `a` going from left to right.
    ///
    /// That is, the result is of the form: `f(...f(f(s, a[0]), a[1])..., xn)`.
    ///
    pub def foldLeft(f: (b, a) -> b \ ef, s: b, arr: Array[a, r]): b \ { ef, Read(r) } =
        let len = length(arr);
        def loop(i, acc) = {
            if (i >= len)
                acc
            else
                loop(i + 1, f(acc, arr[i]))
        };
        loop(0, s)

    ///
    /// Applies `f` to a start value `s` and all elements in `a` going from right to left.
    ///
    /// That is, the result is of the form: `f(a[0], ...f(a[n-1], f(a[n], s))...)`.
    ///
    pub def foldRight(f: (a, b) -> b \ ef, s: b, arr: Array[a, r]): b \ { ef, Read(r) } =
        def loop(i, acc) = {
            if (i < 0)
                acc
            else
                loop(i - 1, f(arr[i], acc))
        };
        loop(length(arr) - 1, s)

    ///
    /// Applies `f` to a start value `z` and all elements in `a` going from right to left.
    ///
    /// That is, the result is of the form: `f(a[0], ...f(a[n-1], f(a[n], z))...)`.
    /// A `foldRightWithCont` allows early termination by not calling the continuation.
    ///
    pub def foldRightWithCont(f: (a, Unit -> b \ {ef,  r}) -> b \ {ef, r}, z: b, arr: Array[a, r]): b \ { ef, Read(r) } =
        def loop(i) = {
            if (i == length(arr))
                z
            else
                f(arr[i], _ -> loop(i + 1))
        };
        loop(0)

    ///
    /// Returns the result of mapping each element and combining the results.
    ///
    pub def foldMap(f: a -> b \ ef, arr: Array[a, r]): b \ { ef, Read(r) } with Monoid[b] =
        foldLeft((acc, x) -> Monoid.combine(acc, f(x)), Monoid.empty(), arr)

    ///
    /// Applies `f` to all elements in `a` going from left to right until a single value `v` is obtained.  Returns `Some(v)`.
    ///
    /// Returns `None` if `a` is empty.
    ///
    pub def reduceLeft(f: (a, a) ->  a \ ef, a: Array[a, r]): Option[a] \ { ef, Read(r) } =
        let len = length(a);
        def loop(i, acc) = {
            if (i >= len)
                acc
            else
                loop(i + 1, f(acc, a[i]))
        };
        if (len == 0)
            None
        else
            Some(loop(1, a[0]))

    ///
    /// Applies `f` to all elements in `arr` going from right to left until a single value `v` is obtained.  Returns `Some(v)`.
    ///
    /// Returns `None` if `arr` is empty.
    ///
    pub def reduceRight(f: (a, a) -> a \ ef, arr: Array[a, r]): Option[a] \ { ef, Read(r) } =
        let len = length(arr);
        def loop(i, acc) = {
            if (i < 0)
                acc
            else
                loop(i - 1, f(arr[i], acc))
        };
        if (len == 0)
            None
        else
            Some(loop(len - 2, arr[len - 1]))

    ///
    /// Returns the number of elements in `a` that satisfy the predicate `f`.
    ///
    pub def count(f: a -> Bool \ ef, a: Array[a, r]): Int32 \ { ef, Read(r) } =
        foldLeft((b, x) -> if (f(x)) b + 1 else b, 0, a)

    ///
    /// Returns the sum of all elements in the array `a`.
    ///
    pub def sum(a: Array[Int32, r]): Int32 \ Read(r) =
        foldLeft((acc, x) -> acc + x, 0, a)

    ///
    /// Returns the sum of all elements in the array `a` according to the function `f`.
    ///
    pub def sumWith(f: a -> Int32 \ ef, a: Array[a, r]): Int32 \ { ef, Read(r) } =
        foldLeft((acc, x) -> acc + f(x), 0, a)

    ///
    /// Returns the product of all elements in the array `a`.
    ///
    pub def product(a: Array[Int32, r]): Int32 \ Read(r) =
        if (isEmpty(a))
            1
        else
            foldLeft((acc, x) -> acc * x, 1, a)

    ///
    /// Returns the product of all elements in the array `a` according to the function `f`.
    ///
    pub def productWith(f: a -> Int32 \ ef, a: Array[a, r]): Int32 \ { ef, Read(r) } =
        if (isEmpty(a))
            1
        else
            foldLeft((acc, x) -> acc * f(x), 1, a)

    ///
    /// Returns the concatenation of the arrays of in the array `arrs`.
    ///
    pub def flatten(r1: Region[r1], arrs: Array[Array[a, r], r]) : Array[a, r1] \ { Read(r), Write(r1) } =
        let len = sumLengths(arrs);
        match headArrays(arrs) {
            case None => Array#{} @ r1
            case Some(x) => {
                let out = repeat(r1, len, x);
                discard foldLeft((pos, a) -> arrayWrites(pos, a, out), 0, arrs);
                out
            }
        }

    ///
    /// Returns `true` if and only if at least one element in `arr` satisfies the predicate `f`.
    ///
    /// Returns `false` if `arr` is empty.
    ///
    pub def exists(f: a -> Bool \ ef, arr: Array[a, r]): Bool \ { ef, Read(r) } =
        let len = length(arr);
        def loop(i) = {
            if (i >= len)
                false
            else if (f(arr[i]))
                true
            else
                loop(i + 1)
        };
        loop(0)

    ///
    /// Returns `true` if and only if all elements in `arr` satisfy the predicate `f`.
    ///
    /// Returns `true` if `arr` is empty.
    ///
    pub def forAll(f: a -> Bool \ ef, arr: Array[a, r]): Bool \ { ef, Read(r) } =
        let len = length(arr);
        def loop(i) = {
            if (i >= len)
                true
            else if (f(arr[i]))
                loop(i + 1)
            else
                false
        };
        loop(0)

    ///
    /// Returns an array of every element in `arr` that satisfies the predicate `f`.
    ///
    pub def filter(r1: Region[r1], f: a -> Bool \ ef, arr: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        let len = length(arr);
        if (len < 1) {
            Array#{} @ r1
        } else {
            let out = new(r1, len);
            def loop(i, j) = {
                if (i >= len)
                    j
                else {
                    let x = arr[i];
                    if (f(x)) {
                        out[j] = x;
                        loop(i + 1, j + 1)
                    } else {
                        loop(i + 1, j)
                    }
                }
            };
            let endPos = loop(0, 0);
            copyOfRange(r1, 0, endPos, out)
        }

    ///
    /// Returns a pair of arrays `(a1, a2)`.
    ///
    /// `a1` contains all elements of `a` that satisfy the predicate `f`.
    /// `a2` contains all elements of `a` that do not satisfy the predicate `f`.
    ///
    pub def partition(r1: Region[r1], r2: Region[r2], f: a -> Bool \ ef, a: Array[a, r]): (Array[a, r1], Array[a, r2]) \ { ef, Read(r), Write(r1), Write(r2) } =
        let step = { (x, acc) ->
            let (a1, a2) = acc;
            if (f(x)) (x :: a1, a2) else (a1, x :: a2)
        };
        let (xs, ys) = foldRight(step, (Nil, Nil), a);
        (List.toArray(r1, xs), List.toArray(r2, ys))

    ///
    /// Returns a pair of arrays `(a1, a2)`.
    ///
    /// `a1` is the longest prefix of `a` that satisfies the predicate `f`.
    /// `a2` is the remainder of `a`.
    ///
    pub def span(r1: Region[r1], r2: Region[r2], f: a -> Bool \ ef, a: Array[a, r]): (Array[a, r1], Array[a, r2]) \ { ef, Read(r), Write(r1), Write(r2) } =
        match findIndexOfLeft(x -> not (f(x)), a) {
            case None    => (takeLeft(r1, length(a), a), Array#{} @ r2)
            case Some(i) => (takeLeft(r1, i, a), dropLeft(r2, i, a))
        }

    ///
    /// Alias for `dropLeft`.
    ///
    pub def drop(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        dropLeft(r1, n, a)

    ///
    /// Returns a copy of array `a`, dropping the first `n` elements.
    ///
    /// Returns `[]` if `n > length(a)`.
    ///
    pub def dropLeft(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let len = length(a);
        if (n > len)
            Array#{} @ r1
        else {
            let start = if (n < 0) 0 else n;
            copyOfRange(r1, start, len, a)
        }

    ///
    /// Returns a copy of array `a`, dropping the last `n` elements.
    ///
    /// Returns `[]` if `n > length(a)`.
    ///
    pub def dropRight(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let len = length(a);
        if (n >= len)
            Array#{} @ r1
        else {
            let end = if (n < 0) len else len - n;
            copyOfRange(r1, 0, end, a)
        }

    ///
    /// Alias for `dropWhileLeft`.
    ///
    pub def dropWhile(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        dropWhileLeft(r1, f, a)

    ///
    /// Returns copy of array `a` without the longest prefix that satisfies the predicate `f`.
    ///
    pub def dropWhileLeft(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        match findIndexOfLeft(x -> not (f(x)), a) {
            case None    => Array#{} @ r1
            case Some(i) => dropLeft(r1, i, a)
        }

    ///
    /// Returns copy of array `a` without the longest suffix that satisfies the predicate `f`.
    ///
    pub def dropWhileRight(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        match findIndexOfRight(x -> not (f(x)), a) {
            case None    => Array#{} @ r1
            case Some(i) => copyOfRange(r1, 0, i + 1, a)
        }

    ///
    /// Alias for `takeLeft`.
    ///
    pub def take(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        takeLeft(r1, n, a)

    ///
    /// Returns a fresh array taking first `n` elements of `a`.
    ///
    /// Returns `a` if `n > length(xs)`.
    ///
    pub def takeLeft(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        if (n <= 0)
            Array#{} @ r1
        else {
            let len = length(a);
            let end = if (n > len) len else n;
            copyOfRange(r1, 0, end, a)
        }

    ///
    /// Returns a fresh array taking last `n` elements of `a`.
    ///
    /// Returns `a` if `n > length(xs)`.
    ///
    pub def takeRight(r1: Region[r1], n: Int32, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        if (n <= 0)
            Array#{} @ r1
        else {
            let len = length(a);
            let start = if (n > len) 0 else len - n;
            copyOfRange(r1, start, len, a)
        }

    ///
    /// Alias for `takeWhileLeft`.
    ///
    pub def takeWhile(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        takeWhileLeft(r1, f, a)

    ///
    /// Returns the longest prefix of `a` that satisfies the predicate `f`.
    ///
    pub def takeWhileLeft(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        match findIndexOfLeft(x -> not (f(x)), a) {
            case None    => copyOfRange(r1, 0, length(a), a)
            case Some(i) => takeLeft(r1, i, a)
        }

    ///
    /// Returns the longest suffix of `a` that satisfies the predicate `f`.
    ///
    pub def takeWhileRight(r1: Region[r1], f: a -> Bool \ ef, a: Array[a, r]): Array[a, r1] \ { ef, Read(r), Write(r1) } =
        match findIndexOfRight(x -> not (f(x)), a) {
            case None    => copyOfRange(r1, 0, length(a), a)
            case Some(i) => copyOfRange(r1, i + 1, length(a), a)
        }

    ///
    /// Partitions `a` into subarrays such that for any two elements `x` and `y` in a subarray, `f(x, y)` is true.
    ///
    /// A subarray is created by iterating through the remaining elements of `a` from left to right and adding an
    /// element to the subarray if and only if doing so creates no conflicts with the elements already in the subarray.
    ///
    /// The function `f` must be pure.
    ///
    pub def groupBy(r1: Region[r1], f: (a, a) -> Bool, a: Array[a, r2]): Array[Array[a, r1], r1] \ { Read(r2), Write(r1) } =
        let xs = toList(a);
        groupByHelper(r1, f, xs, Nil) |> List.toArray(r1)

    ///
    /// Helper function for `groupBy`.
    ///
    def groupByHelper(r: Region[r], f: (a, a) -> Bool, xs: List[a], ac: List[Array[a, r]]): List[Array[a, r]] \ Write(r) = match xs {
        case Nil     => List.reverse(ac)
        case x :: rs =>
            let (r1, r2) = extractHelper(r, f, rs, x :: Nil, Nil);
            groupByHelper(r, f, r2, r1 :: ac)
    }

    ///
    /// Helper function for `groupBy`.
    ///
    def extractHelper(r: Region[r], f: (a, a) -> Bool, xs: List[a], ps: List[a], ns: List[a]): (Array[a, r], List[a]) \ Write(r) = match xs {
        case Nil => {
            let a = List.reverse(ps);
            (List.toArray(r, a), List.reverse(ns))
        }
        case x :: rs =>
            if (agreeHelper(f, x, ps))
                extractHelper(r, f, rs, x :: ps, ns)
            else
                extractHelper(r, f, rs, ps, x :: ns)
    }

    ///
    /// Helper function for `groupBy`.
    ///
    def agreeHelper(f: (a, a) -> Bool, a: a, xs: List[a]): Bool = match xs {
        case Nil => true
        case x :: rs =>
            if ((f(x, a) and f(a, x)) == false)
                false
            else
                agreeHelper(f, a, rs)
    }

    ///
    /// Returns an array where the element at index `i` is `(x, y)` where
    /// `x` is the element at index `i` in `a` and `y` is the element at index `i` in `b`.
    ///
    /// If either `a` or `b` becomes depleted, then no further elements are added to the resulting array.
    ///
    pub def zip(r3: Region[r3], a: Array[a, r1], b: Array[b, r2]): Array[(a, b), r3] \ { Read(r1, r2), Write(r3) } =
        let len = Int32.min(length(a), length(b));
        init(r3, i -> (a[i], b[i]), len)

    ///
    /// Returns an array where the element at index `i` is `f(x, y)` where
    /// `x` is the element at index `i` in `a` and `y` is the element at index `i` in `b`.
    ///
    /// If either `a` or `b` becomes depleted, then no further elements are added to the resulting array.
    ///
    pub def zipWith(r3: Region[r3], f: (a, b) -> c \ ef, a: Array[a, r1], b: Array[b, r2]): Array[c, r3] \ { ef, Read(r1, r2), Write(r3) } =
        let len = Int32.min(length(a), length(b));
        init(r3, i -> f(a[i], b[i]), len)

    ///
    /// Returns a pair of arrays, the first containing all first components in `a`
    /// and the second containing all second components in `a`.
    ///
    pub def unzip(r1: Region[r1], r2: Region[r2], a: Array[(a, b), r3]): (Array[a, r1], Array[b, r2]) \ { Write(r1, r2), Read(r3) } =
        let len = length(a);
        if (len <= 0)
            (Array#{} @ r1, Array#{} @ r2)
        else {
            let (x, y) = a[0];
            let arr = repeat(r1, len, x);
            let brr = repeat(r2, len, y);
            def loop(i) = {
                if (i < len) {
                    let (l, r) = a[i];
                    arr[i] = l;
                    brr[i] = r;
                    loop(i + 1)
                } else
                    ()
            };
            loop(1);
            (arr, brr)
        }

    ///
    /// Alias for `foldLeft2`.
    ///
    pub def fold2(f: (c, a, b) -> c \ ef, c: c, a: Array[a, r1], b: Array[b, r2]): c \ { ef, Read(r1, r2) } =
        foldLeft2(f, c, a, b)

    ///
    /// Accumulates the result of applying `f` pairwise to the elements of `a` and `b`
    /// starting with the initial value `c` and going from left to right.
    ///
    pub def foldLeft2(f: (c, a, b) ->  c \ ef, c: c, a: Array[a, r1], b: Array[b, r2]): c \ { ef, Read(r1, r2) } =
        let lena = length(a);
        let lenb = length(b);
        def loop(i, acc) = {
            if (i >= lena or i >= lenb)
                acc
            else
                loop(i + 1, f(acc, a[i], b[i]))
        };
        loop(0, c)

    ///
    /// Accumulates the result of applying `f` pairwise to the elements of `a` and `b`
    /// starting with the initial value `c` and going from right to left.
    ///
    pub def foldRight2(f: (a, b, c) -> c \ ef, c: c, a: Array[a, r1], b: Array[b, r2]): c \ { ef, Read(r1, r2) } =
        def loop(i, j, acc) = {
            if (i < 0 or j < 0)
                acc
            else
                loop(i - 1, j - 1, f(a[i], b[j], acc))
        };
        let starta = length(a) - 1;
        let startb = length(b) - 1;
        loop(starta, startb, c)

    ///
    /// Collects the results of applying the partial function `f` to every element in `a`.
    ///
    pub def filterMap(r1: Region[r1], f: a -> Option[b] \ ef, a: Array[a, r]): Array[b, r1] \ { ef, Read(r), Write(r1) } =
        foldRight((x, xs) -> match f(x) {
            case None    => xs
            case Some(b) => b :: xs }, Nil, a) |> List.toArray(r1)

    ///
    /// Returns the first non-None result of applying the partial function `f` to each element of `xs`.
    ///
    /// Returns `None` if every element of `xs` is `None`.
    ///
    pub def findMap(f: a -> Option[b] \ ef, a: Array[a, r]): Option[b] \ { ef, Read(r) } =
        let len = length(a);
        def loop(i) = {
            if (i >= len)
                None
            else
                let x = f(a[i]);
                match x {
                    case Some(v) => Some(v)
                    case None    => loop(i + 1)
                }
        };
        loop(0)

    ///
    /// Returns the array `a` as a set.
    ///
    pub def toSet(a: Array[a, r]): Set[a] \ Read(r) with Order[a] =
        foldRight(Set.insert, Set.empty(), a)

    ///
    /// Returns the association list `xs` as a map.
    ///
    /// If `xs` contains multiple mappings with the same key, `toMap` does not
    /// make any guarantees about which mapping will be in the resulting map.
    ///
    pub def toMap(a: Array[(a, b), r]): Map[a, b] \ Read(r) with Order[a] =
        foldRight((x, m) -> Map.insert(fst(x), snd(x), m), Map.empty(), a)

    ///
    /// Returns the array `a` as a MutList.
    ///
    pub def toMutList(r1: Region[r1], a: Array[a, r2]): MutList[a, r1] \ { Read(r2), Write(r1) } =
        let minCap = MutList.minCapacity();
        let len = length(a);
        let c = Order.max(len, minCap);
        let copy = copyOfRange(r1, 0, c, a);
        MutList.MutList(r1, ref copy @ r1, ref len @ r1)

    ///
    /// Alias for `findIndexOfLeft`.
    ///
    pub def findIndexOf(f: a -> Bool \ ef, a: Array[a, r]): Option[Int32] \ { ef, Read(r) } =
        findIndexOfLeft(f,a)

    ///
    /// Optionally returns the position of the first element in `x` satisfying `f`.
    ///
    pub def findIndexOfLeft(f: a -> Bool \ ef, a: Array[a, r]): Option[Int32] \ { ef, Read(r) } =
        let len = length(a);
        if (len < 1)
            None
        else {
            def loop(i) = {
                if (i >= len)
                    -1
                else if (f(a[i]))
                    i
                else
                    loop(i + 1)
            };
            let i = loop(0);
            if (i < 0) None else Some(i)
        }

    ///
    /// Optionally returns the position of the first element in `a` satisfying `f`
    /// searching from right to left.
    ///
    pub def findIndexOfRight(f: a -> Bool \ ef, a: Array[a, r]): Option[Int32] \ { ef, Read(r) } =
        let len = length(a);
        def loop(i) = {
            if (i < 0)
                -1
            else if (f(a[i]))
                i
            else
                loop(i - 1)
        };
        let i = loop(len - 1);
        if (i < 0) None else Some(i)

    ///
    /// Returns the positions of the all the elements in `a` satisfying `f`.
    ///
    pub def findIndices(r2: Region[r2], f: a -> Bool \ ef, a: Array[a, r1]): Array[Int32, r2] \ { ef, Read(r1), Write(r2) } =
        let len = length(a);
        let l = new MutList(r2);
        def loop(i) = {
            if (i >= len)
                ()
            else {
                if (f(a[i])) MutList.push!(i, l) else ();
                loop(i + 1)
            }
        };
        loop(0);
        MutList.toArray(r2, l)

    ///
    /// Build an array of length `len` by applying `f` to the successive indices.
    ///
    pub def init(r: Region[r], f: Int32 -> a \ ef, len: Int32): Array[a, r] \ { ef, Write(r) } =
        if (len <= 0)
            Array#{} @ r
        else {
            let x = f(0);
            let a = Array.repeat(r, len, x);
            def loop(i) = {
                if (i < len) {
                    a[i] = f(i);
                    loop(i + 1)
                } else
                    ()
            };
            loop(1);
            a
        }

    ///
    /// Returns `true` if arrays `a` and `b` have the same elements in the same order, i.e. are structurally equal.
    ///
    pub def sameElements(a: Array[a, r1], b: Array[a, r2]): Bool \ Read(r1, r2) with Eq[a] =
        let alen = length(a);
        let blen = length(b);
        def loop(i) = {
            if (i >= alen)
                true
            else if (a[i] != b[i])
                false
            else
                loop(i + 1)
        };
        if (alen == blen)
            loop(0)
        else
            false

    ///
    /// Returns an iterator over `a`
    ///
    /// Modifying `a` while using an iterator has undefined behavior and is dangerous.
    ///
    pub def iterator(rc: Region[r1], a: Array[a, r2]): Iterator[a, r1 and r2, r1] \ { Write(r1) } =
        Iterator.range(rc, 0, length(a)) |> Iterator.map(i -> Array.get(i, a))

    ///
    /// Returns an iterator over `a` zipped with the indices of the elements.
    ///
    /// Modifying `a` while using an iterator has undefined behavior and is dangerous.
    ///
    pub def enumerator(rc: Region[r1], a: Array[a, r2]): Iterator[(Int32, a), r1 and r2, r1] \ { Write(r1) } =
        iterator(rc, a) |> Iterator.zipWithIndex

    ///
    /// Apply the effectful function `f` to all the elements in the array `a`.
    ///
    pub def forEach(f: a -> Unit \ ef, a: Array[a, r]): Unit \ { ef, Read(r) } =
        let len = length(a);
        def loop(i) = {
            if (i >= len)
                ()
            else {
                f(a[i]);
                loop(i + 1)
            }
        };
        loop(0)

    ///
    /// Apply the effectful function `f` to all the elements in the array `a`.
    ///
    pub def forEachWithIndex(f: (Int32, a) -> Unit \ ef, a: Array[a, r]): Unit \ { ef, Read(r) } =
        let len = length(a);
        def loop(i) = {
            if (i >= len)
                ()
            else {
                f(i, a[i]);
                loop(i + 1)
            }
        };
        loop(0)

    ///
    /// Returns a copy of `a` with the elements starting at index `i` replaced by `sub`.
    ///
    pub def updateSequence(r3: Region[r3], i: Int32, sub: Array[a, r1], a: Array[a, r2]): Array[a, r3] \ { Read(r1, r2), Write(r3) } =
        let end = i + length(sub);
        let f = ix -> if (ix >= i and ix < end) sub[ix - i] else a[ix];
        let len = length(a);
        init(r3, f, len)

    ///
    /// Update the mutable array `a` with the elements starting at index `i` replaced by `sub`.
    ///
    pub def updateSequence!(i: Int32, sub: Array[a, r1], a: Array[a, r2]): Unit \ { Read(r1), Write(r2) } =
        let end = i + length(sub);
        let f = { (ix, _) ->
            if (ix >= i and ix < end)
                a[ix] = sub[ix-i]
            else
                ()
        };
        forEachWithIndex(f, a)

    ///
    /// Returns the concatenation of the string representation
    /// of each element in `a` with `sep` inserted between each element.
    ///
    pub def join(sep: String, a: Array[a, r]): String \ Read(r) with ToString[a] =
        joinWith(ToString.toString, sep, a)

    ///
    /// Returns the concatenation of the string representation
    /// of each element in `a` according to `f` with `sep` inserted between each element.
    ///
    pub def joinWith(f: a -> String \ ef, sep: String, a: Array[a, r]): String \ { ef, Read(r) } = region r1 {
        use StringBuilder.append!;
        let lastSep = String.length(sep);
        let sb = new StringBuilder(r1);
        forEach(x -> { append!(f(x), sb); append!(sep, sb) }, a);
        StringBuilder.toString(sb) |> String.dropRight(lastSep)
    }

    ///
    /// Returns a sorted copy of array `a`, where the elements are ordered from low to high according to
    /// their `Order` instance.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sort(r1: Region[r1], a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } with Order[a] =
        sortWith(r1, Order.compare, a)

    ///
    /// Returns a sorted copy of array `a`, where the elements are ordered from low to high according to
    /// the `Order` instance for the values obtained by applying `f` to each element.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sortBy(r1: Region[r1], f: a -> b, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } with Order[b] =
        sortWith(r1, Order.compare `on` f, a)

    ///
    /// Returns a sorted copy of array `a`, where the elements are ordered from low to high according to
    /// the comparison function `cmp`.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sortWith(r1: Region[r1], cmp: (a,a) -> Comparison, a: Array[a, r]): Array[a, r1] \ { Read(r), Write(r1) } =
        let len = length(a);
        let b = copyOfRange(r1, 0, len, a);
        sortWith!(cmp, b);
        b

    ///
    /// Sort array `a` so that elements are ordered from low to high according to their `Order` instance.
    /// The array is mutated in-place.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sort!(a: Array[a, r]): Unit \ { Read(r), Write(r) } with Order[a] =
        sortWith!(Order.compare, a)

    ///
    /// Sort array `a` so that elements are ordered from low to high according to the `Order` instance for
    /// the values obtained by applying `f` to each element. The array is mutated in-place.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sortBy!(f: a -> b, a: Array[a, r]): Unit \ { Read(r), Write(r) } with Order[b] =
        sortWith!(Order.compare `on` f, a)

    ///
    /// Sort array `a` so that elements are ordered from low to high according to the comparison function `cmp`.
    /// The array is mutated in-place.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sortWith!(cmp: (a,a) -> Comparison, a: Array[a, r]): Unit \ { Read(r), Write(r) } =
        sortWithin!(cmp, 0, length(a) - 1, a)

    ///
    /// Sort array `a` between the indices `lo` and `hi` (both inclusive) so that elements in that range are ordered
    /// from low to high according to the comparison function `cmp`. The array is mutated in-place where elements
    /// outside the specified range are not changed. If `lo >= hi`, this does nothing.
    ///
    /// The sort is not stable, i.e., equal elements may appear in a different order than in the input `a`.
    ///
    /// The sort implementation is a Quicksort.
    ///
    pub def sortWithin!(cmp: (a,a) -> Comparison, lo: Int32, hi: Int32, a: Array[a, r]): Unit \ { Read(r), Write(r) }=
        if (lo >= hi)
            ()
        else {
            let p = quicksortPartition(cmp, a, lo, hi);
            sortWithin!(cmp, lo, p - 1, a);
            sortWithin!(cmp, p + 1, hi, a)
        }

    ///
    /// Swap the elements at `i` and `j` (helper for sorting).
    ///
    /// Precondition: `i` and `j` are within bounds.
    ///
    pub def swap!(i: Int32, j: Int32, a: Array[a, r]): Unit \ { Read(r), Write(r) } =
        let x = a[i];
        let y = a[j];
        a[i] = y;
        a[j] = x;
        ()

    ///
    /// Partition step of the Quicksort algorithm.
    ///
    def quicksortPartition(cmp: (a,a) -> Comparison, a: Array[a, r], lo: Int32, hi: Int32): Int32 \ { Read(r), Write(r) } =
        let pivot = a[hi];
        let i = forWithAccum(lo, hi, lo, (j,ix) ->
            if (cmp(a[j], pivot) == Comparison.LessThan) {
                swap!(ix, j, a);
                ix+1
            } else
                ix
            );
        swap!(i, hi, a);
        i

    ///
    /// A for loop with an accumulator (helper for sorting).
    ///
    /// precondition: lo <= hi
    ///
    def forWithAccum(lo: Int32, hi: Int32, ac: a, f: (Int32, a) -> a \ ef): a \ ef =
        if (lo == hi)
            f(lo, ac)
        else {
            let ac1 = f(lo, ac);
            forWithAccum(lo+1, hi, ac1, f)
        }

    ///
    /// Copies the range between `b` (inclusive) and `e` (exclusive) of a into a new array.
    ///
    /// A valid range has the following properties:
    ///   - 0 <= `b` <= `length(a)`.
    ///   - `e` >= `b`.
    /// If the range is valid and greater than the length of `a`, the resulting array with have the length of the range
    /// and include the specified range of `a`.
    ///
    pub def copyOfRange(_: Region[r2], b: Int32, e: Int32, a: Array[a, r1]): Array[a, r2] \ { Read(r1), Write(r2) } =
        typematch a {
            case arr: Array[Unit, r1] =>
                import static java.util.Arrays.copyOfRange(Array[##java.lang.Object, r1], Int32, Int32): Array[##java.lang.Object, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(unsafe_cast arr as Array[##java.lang.Object, r1], b, e) as Array[a, r2]
            case arr: Array[Bool, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Bool, r1], Int32, Int32): Array[Bool, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Char, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Char, r1], Int32, Int32): Array[Char, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Float32, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Float32, r1], Int32, Int32): Array[Float32, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Float64, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Float64, r1], Int32, Int32): Array[Float64, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[BigDecimal, r1] =>
                import static java.util.Arrays.copyOfRange(Array[##java.lang.Object, r1], Int32, Int32): Array[##java.lang.Object, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(unsafe_cast arr as Array[##java.lang.Object, r1], b, e) as Array[a, r2]
            case arr: Array[Int8, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Int8, r1], Int32, Int32): Array[Int8, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Int16, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Int16, r1], Int32, Int32): Array[Int16, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Int32, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Int32, r1], Int32, Int32): Array[Int32, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[Int64, r1] =>
                import static java.util.Arrays.copyOfRange(Array[Int64, r1], Int32, Int32): Array[Int64, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(arr, b, e) as Array[a, r2]
            case arr: Array[BigInt, r1] =>
                import static java.util.Arrays.copyOfRange(Array[##java.lang.Object, r1], Int32, Int32): Array[##java.lang.Object, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(unsafe_cast arr as Array[##java.lang.Object, r1], b, e) as Array[a, r2]
            case arr: Array[String, r1] =>
                import static java.util.Arrays.copyOfRange(Array[##java.lang.Object, r1], Int32, Int32): Array[##java.lang.Object, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(unsafe_cast arr as Array[##java.lang.Object, r1], b, e) as Array[a, r2]
            case arr: Array[a, r1] =>
                import static java.util.Arrays.copyOfRange(Array[##java.lang.Object, r1], Int32, Int32): Array[##java.lang.Object, r2] \ { Read(r1), Write(r2) } as copy;
                unsafe_cast copy(unsafe_cast arr as Array[##java.lang.Object, r1], b, e) as Array[a, r2]
            case _: _ => unreachable!()
        }

    ///
    /// Shuffles `a` using the Fisher–Yates shuffle.
    ///
    pub def shuffle(rnd: Random, a: Array[a, r]): Unit & r \ NonDet =
        let len = Array.length(a);
        def loop(i) = {
            if (i > 0) {
                let j = Random.nextNatWithMax(rnd, i + 1);
                Array.swap!(i, j, a);
                loop(i - 1)
            }
            else
                ()
        };
        loop(len - 1)

}
